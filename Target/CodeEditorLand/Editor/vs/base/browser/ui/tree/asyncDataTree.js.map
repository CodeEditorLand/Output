{
  "version": 3,
  "sources": ["../../../../../../../../../../Dependency/Land/Dependency/Editor/Source/vs/base/browser/ui/tree/asyncDataTree.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd.js';\nimport { IIdentityProvider, IListDragAndDrop, IListDragOverReaction, IListVirtualDelegate } from '../list/list.js';\nimport { ElementsDragAndDropData, ListViewTargetSector } from '../list/listView.js';\nimport { IListStyles } from '../list/listWidget.js';\nimport { ComposedTreeDelegate, TreeFindMode as TreeFindMode, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, TreeFindMatchType, AbstractTreePart, LabelFuzzyScore, IFindFilter, AbstractFindController, ITreeFindToggleContribution, ITreeFindToggleChangeEvent } from './abstractTree.js';\nimport { ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ICompressibleKeyboardNavigationLabelProvider, ICompressibleObjectTreeOptions, ICompressibleTreeRenderer, IObjectTreeOptions, IObjectTreeSetChildrenOptions, ObjectTree } from './objectTree.js';\nimport { IAsyncDataSource, ICollapseStateChangeEvent, IObjectTreeElement, ITreeContextMenuEvent, ITreeDragAndDrop, ITreeEvent, ITreeFilter, ITreeModel, ITreeMouseEvent, ITreeNavigator, ITreeNode, ITreeRenderer, ITreeSorter, ObjectTreeElementCollapseState, TreeError, TreeFilterResult, TreeVisibility, WeakMapper } from './tree.js';\nimport { CancelablePromise, createCancelablePromise, Promises, timeout, TimeoutTimer } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose, IDisposable } from '../../../common/lifecycle.js';\nimport { ScrollEvent } from '../../../common/scrollable.js';\nimport { isIterable, isNumber } from '../../../common/types.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../common/cancellation.js';\nimport { IObjectTreeModel } from './objectTreeModel.js';\nimport { IContextViewProvider } from '../contextview/contextview.js';\nimport { FuzzyScore } from '../../../common/filters.js';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\trefreshPromise: Promise<void> | undefined;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n\tforceExpanded: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\trefreshPromise: undefined,\n\t\tstale: true,\n\t\tslow: false,\n\t\tforceExpanded: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\ntype AsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>, ITreeNode<TInput | T, TFilterData>>;\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass AsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\n\tconstructor(\n\t\tprotected renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e!.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\ttarget: e.target\n\t};\n}\n\nfunction asTreeContextMenuEvent<TInput, T>(e: ITreeContextMenuEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeContextMenuEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\tanchor: e.anchor,\n\t\tisStickyScroll: e.isStickyScroll\n\t};\n}\n\nclass AsyncDataTreeElementsDragAndDropData<TInput, T, TContext> extends ElementsDragAndDropData<T, TContext> {\n\n\toverride set context(context: TContext | undefined) {\n\t\tthis.data.context = context;\n\t}\n\n\toverride get context(): TContext | undefined {\n\t\treturn this.data.context;\n\t}\n\n\tconstructor(private data: ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>, TContext>) {\n\t\tsuper(data.elements.map(node => node.element as T));\n\t}\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\treturn new AsyncDataTreeElementsDragAndDropData(data);\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[], originalEvent: DragEvent): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T), originalEvent);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tonDragEnd(originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragEnd?.(originalEvent);\n\t}\n\n\tdispose(): void {\n\t\tthis.dnd.dispose();\n\t}\n}\n\nexport interface IAsyncFindResult<T> {\n\telement: T;\n\tfilterdata?: FuzzyScore | LabelFuzzyScore;\n}\n\nexport interface IAsyncFindProvider<T> {\n\ttoggles?: ITreeFindToggleContribution[];\n\tplaceholder?: string;\n\tgetFindResults(pattern: string, sessionId: number, token: CancellationToken, toggleStates: { id: string; isChecked: boolean }[]): AsyncIterable<IAsyncFindResult<T>>;\n\trevealResultInTree?(findElement: T): void;\n}\n\nclass AsyncFindTreeNode<T> {\n\n\tprivate _children: AsyncFindTreeNode<T>[] = [];\n\tget children(): Iterable<AsyncFindTreeNode<T>> {\n\t\treturn this._children.values();\n\t}\n\n\tconstructor(\n\t\tpublic element: T | undefined,\n\t\tpublic id: string,\n\t\tprivate readonly sorter: ITreeSorter<T> | undefined,\n\t) { }\n\n\taddChild(child: AsyncFindTreeNode<T>): void {\n\t\tif (!this.sorter) {\n\t\t\tthis._children.push(child);\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this._children.findIndex(existingChild => this.sorter!.compare(child.element!, existingChild.element!) < 0);\n\t\tif (index !== -1) {\n\t\t\tthis._children.splice(index, 0, child);\n\t\t} else {\n\t\t\tthis._children.push(child);\n\t\t}\n\t}\n}\n\nclass AsyncFindTree<TInput, T> {\n\n\tprivate cachedNodes = new Map<string, AsyncFindTreeNode<T>>();\n\tprivate readonly root = new AsyncFindTreeNode<T>(undefined, '_AsyncFindTreeRoot_', this.sorter);\n\tget rootNodes(): AsyncFindTreeNode<T>[] {\n\t\treturn [...this.root.children];\n\t}\n\n\tprivate _totalLeafs: number = 0;\n\tget totalLeafs(): number {\n\t\treturn this._totalLeafs;\n\t}\n\n\tget totalNodes(): number {\n\t\treturn this.cachedNodes.size;\n\t}\n\n\tprivate _results: IAsyncFindResult<T>[] = [];\n\tget results(): IAsyncFindResult<T>[] {\n\t\treturn [...this._results];\n\t}\n\n\tconstructor(\n\t\tprivate readonly dataSource: IAsyncDataSource<TInput, T>,\n\t\tprivate readonly identityProvider: IIdentityProvider<T>,\n\t\tprivate readonly sorter?: ITreeSorter<T>,\n\t) {\n\t\tif (!dataSource.getParent) {\n\t\t\tthrow new Error('Data source must implement `getParent`');\n\t\t}\n\t}\n\n\tadd(result: IAsyncFindResult<T>): void {\n\t\tthis._results.push(result);\n\n\t\tconst element = result.element;\n\t\tconst elementId = this.identityProvider.getId(element).toString();\n\t\tif (this.cachedNodes.has(elementId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._totalLeafs++;\n\n\t\tconst node = new AsyncFindTreeNode(element, elementId, this.sorter);\n\t\tthis.cachedNodes.set(elementId, node);\n\n\t\t// Set up parents up till root\n\t\tlet currentNode = node;\n\t\twhile (true) {\n\t\t\tlet currentParentElement = this.dataSource.getParent!(currentNode.element!);\n\n\t\t\t// is root\n\t\t\tif (currentParentElement === currentNode.element) {\n\t\t\t\tthis.root.addChild(currentNode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentParentElement = currentParentElement as T;\n\n\t\t\t// is already in the tree\n\t\t\tconst parentId = this.identityProvider.getId(currentParentElement).toString();\n\t\t\tconst parentNode = this.cachedNodes.get(parentId);\n\t\t\tif (parentNode) {\n\t\t\t\tparentNode.addChild(currentNode);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// create parent node\n\t\t\tconst newParent = new AsyncFindTreeNode(currentParentElement, parentId, this.sorter);\n\t\t\tthis.cachedNodes.set(parentId, newParent);\n\t\t\tnewParent.addChild(currentNode);\n\n\t\t\tcurrentNode = newParent;\n\t\t}\n\t}\n}\n\nclass AsyncFindFilter<TInput, T> implements IFindFilter<IAsyncDataTreeNode<TInput, T>>, IDisposable {\n\n\tpattern: string = '';\n\n\tprivate findFilterData: Map<T, FuzzyScore | LabelFuzzyScore> = new Map();\n\n\tprivate readonly disposables = new DisposableStore();\n\n\tconstructor(\n\t\tprivate _filter?: ITreeFilter<IAsyncDataTreeNode<TInput, T>, FuzzyScore>,\n\t) { }\n\n\tsetFindResults(findResults: IAsyncFindResult<T>[]): void {\n\t\tthis.findFilterData = new Map(findResults.\n\t\t\tfilter(result => result.filterdata !== undefined).\n\t\t\tmap(result => [result.element, result.filterdata!])\n\t\t);\n\t}\n\n\tfilter(element: IAsyncDataTreeNode<TInput, T>, parentVisibility: TreeVisibility): TreeFilterResult<FuzzyScore | LabelFuzzyScore> {\n\t\tlet visibility = TreeVisibility.Visible;\n\n\t\tif (this._filter) {\n\t\t\tconst result = this._filter.filter(element, parentVisibility);\n\n\t\t\tif (typeof result === 'boolean') {\n\t\t\t\tvisibility = result ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t\t\t} else if (isFilterResult(result)) {\n\t\t\t\tvisibility = getVisibleState(result.visibility);\n\t\t\t} else {\n\t\t\t\tvisibility = result;\n\t\t\t}\n\n\t\t\tif (visibility === TreeVisibility.Hidden) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst filterData = this.findFilterData.get(element.element as T);\n\t\tif (filterData !== undefined) {\n\t\t\treturn { data: filterData, visibility };\n\t\t}\n\n\t\treturn { data: FuzzyScore.Default, visibility };\n\t}\n\n\tdispose(): void {\n\t\tdispose(this.disposables);\n\t}\n}\n\nclass AsyncFindController<TInput, T, TFilterData> extends AbstractFindController<IAsyncDataTreeNode<TInput, T> | null, TFilterData> {\n\n\tdeclare protected readonly filter: AsyncFindFilter<TInput, T>;\n\tprivate readonly model: ITreeModel<IAsyncDataTreeNode<TInput, T> | null, TFilterData, IAsyncDataTreeNode<TInput, T> | null>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\n\tprivate previousScrollTop: number | undefined;\n\tprivate previousFocus: (IAsyncDataTreeNode<TInput, T> | null)[] = [];\n\tprivate previousSelection: (IAsyncDataTreeNode<TInput, T> | null)[] = [];\n\n\tprivate sessionId: number = 0;\n\tprivate active: boolean = false;\n\n\tprivate activeTokenSource: CancellationTokenSource | undefined;\n\tprivate scheduler: TimeoutTimer;\n\n\tprivate readonly store = new DisposableStore();\n\n\tconstructor(\n\t\tprivate readonly user: string,\n\t\tprotected override readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t\tprivate readonly findProvider: IAsyncFindProvider<T>,\n\t\tfilter: AsyncFindFilter<TInput, T>,\n\t\tprivate readonly sorter: ITreeSorter<T> | undefined,\n\t\tprivate readonly dataSource: IAsyncDataSource<TInput, T>,\n\t\tprivate readonly identityProvider: IIdentityProvider<T>,\n\t\tcontextViewProvider: IContextViewProvider,\n\t\toptions: IAbstractTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t\tprivate readonly asTreeElement: (node: IAsyncDataTreeNode<TInput, T>) => IObjectTreeElement<IAsyncDataTreeNode<TInput, T>>,\n\t) {\n\t\tsuper(tree as any, filter, contextViewProvider, { ...options, placeholder: findProvider.placeholder, toggles: findProvider.toggles });\n\n\t\tthis.model = tree.getModel();\n\t\tthis.scheduler = this.store.add(new TimeoutTimer());\n\t}\n\n\tprivate setFindModeActive(active: boolean): void {\n\t\tif (this.active === active) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (active) {\n\t\t\tthis.activateFindMode();\n\t\t} else {\n\t\t\tthis.deactivateFindMode();\n\t\t}\n\n\t\tthis.active = active;\n\t}\n\n\tprivate activateFindMode(): void {\n\t\tthis.sessionId++;\n\n\t\t// store tree view state\n\t\tthis.previousScrollTop = this.tree.scrollTop;\n\t\tthis.previousFocus = this.tree.getFocus();\n\t\tthis.previousSelection = this.tree.getSelection();\n\n\t\tthis.tree.scrollTop = 0;\n\t\tconst findModel = this.tree.createNewModel({ filter: this.filter as ITreeFilter<IAsyncDataTreeNode<TInput, T> | null, TFilterData> });\n\t\tthis.tree.setModel(findModel);\n\t}\n\n\tprivate deactivateFindMode(): void {\n\t\tconst focus = this.tree.getFocus()[0];\n\t\tthis.tree.setModel(this.model);\n\n\t\tif (focus && focus.element && this.findProvider.revealResultInTree) {\n\t\t\tthis.findProvider.revealResultInTree(focus.element as T);\n\t\t} else {\n\t\t\tthis.tree.scrollTop = this.previousScrollTop ?? 0;\n\t\t\tthis.tree.setFocus(this.previousFocus);\n\t\t\tthis.tree.setSelection(this.previousSelection);\n\t\t}\n\n\t\tthis.activeTokenSource = undefined;\n\t\tthis.nodes.clear();\n\t}\n\n\tprotected applyPattern(pattern: string): void {\n\t\tthis.renderMessage(false);\n\t\tthis.scheduler.cancel();\n\t\tthis.activeTokenSource?.cancel();\n\n\t\tif (!pattern) {\n\t\t\tthis.setFindModeActive(false);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.activeTokenSource = new CancellationTokenSource();\n\n\t\tconst results = this.findProvider.getFindResults(pattern, this.sessionId, this.activeTokenSource.token, this.toggles.states());\n\t\tthis.pocessFindResults(results, this.activeTokenSource.token);\n\t}\n\n\tprivate async pocessFindResults(results: AsyncIterable<IAsyncFindResult<T>>, token: CancellationToken): Promise<void> {\n\t\tif (!this.dataSource.getParent || !this.identityProvider) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove all nodes\n\t\tthis.clearFindResults();\n\n\t\tconst findTree = new AsyncFindTree<TInput, T>(this.dataSource, this.identityProvider, this.sorter);\n\t\tfor await (const result of results) {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfindTree.add(result);\n\t\t}\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Redraw at the end\n\t\tthis.setFindResults(findTree);\n\n\t\tthis.activeTokenSource?.dispose();\n\t\tthis.activeTokenSource = undefined;\n\t}\n\n\tprivate clearFindResults(): void {\n\t\tthis.schedule(() => {\n\t\t\tif (!this.active) {\n\t\t\t\tthis.setFindModeActive(true);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.filter.setFindResults([]);\n\t\t\t\tthis.tree.setChildren(null, []);\n\t\t\t}\n\t\t}, 600);\n\t}\n\n\tprivate setFindResults(findTree: AsyncFindTree<TInput, T>): void {\n\t\tconst rootChildren: IObjectTreeElement<IAsyncDataTreeNode<TInput, T>>[] = [];\n\t\tfor (const rootNodes of findTree.rootNodes) {\n\t\t\trootChildren.push(this.asTreeElement(this.findNodeToAsyncNode(rootNodes, null)));\n\t\t}\n\n\t\tthis.schedule(() => {\n\t\t\tthis.setFindModeActive(true);\n\t\t\tthis.filter.setFindResults(findTree.results);\n\t\t\tthis.tree.setChildren(null, rootChildren);\n\t\t\tthis.renderMessage(rootChildren.length === 0);\n\t\t\tthis.alertResults(findTree.totalLeafs);\n\t\t}, 0);\n\t}\n\n\tprotected findNodeToAsyncNode(node: AsyncFindTreeNode<T>, parent: IAsyncDataTreeNode<TInput, T> | null): IAsyncDataTreeNode<TInput, T> {\n\t\tconst children: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tif (node.element === undefined) {\n\t\t\tthrow new TreeError(this.user, 'Found node without an element');\n\t\t}\n\n\t\tconst asyncNode: IAsyncDataTreeNode<TInput, T> = {\n\t\t\telement: node.element,\n\t\t\tparent,\n\t\t\tchildren,\n\t\t\thasChildren: false,\n\t\t\tdefaultCollapseState: ObjectTreeElementCollapseState.PreserveOrExpanded,\n\t\t\tstale: false,\n\t\t\trefreshPromise: undefined,\n\t\t\tslow: false,\n\t\t\tforceExpanded: false\n\t\t};\n\n\t\tfor (const child of node.children) {\n\t\t\tchildren.push(this.findNodeToAsyncNode(child, asyncNode));\n\t\t}\n\n\t\tasyncNode.hasChildren = !!children.length;\n\n\t\tthis.nodes.set(node.element, asyncNode);\n\n\t\treturn asyncNode;\n\t}\n\n\tprivate schedule(fn: () => void, delay: number) {\n\t\tif (delay === 0) {\n\t\t\tthis.scheduler.cancel();\n\t\t\tfn();\n\t\t\treturn;\n\t\t}\n\t\tthis.scheduler.cancelAndSet(fn, delay);\n\t}\n\n\tprotected override onDidToggleChange(e: ITreeFindToggleChangeEvent): void {\n\t\tsuper.onDidToggleChange(e);\n\t\tthis.applyPattern(this.pattern);\n\t}\n\n\tgetDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> | undefined {\n\t\treturn this.nodes.get(element as T);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tthis.store.dispose();\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\t...options.accessibilityProvider,\n\t\t\tgetPosInSet: undefined,\n\t\t\tgetSetSize: undefined,\n\t\t\tgetRole: options.accessibilityProvider.getRole ? (el) => {\n\t\t\t\treturn options.accessibilityProvider!.getRole!(el.element as T);\n\t\t\t} : () => 'treeitem',\n\t\t\tisChecked: options.accessibilityProvider.isChecked ? (e) => {\n\t\t\t\treturn !!(options.accessibilityProvider?.isChecked!(e.element as T));\n\t\t\t} : undefined,\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t},\n\t\t\tgetWidgetAriaLabel() {\n\t\t\t\treturn options.accessibilityProvider!.getWidgetAriaLabel();\n\t\t\t},\n\t\t\tgetWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider!.getWidgetRole!() : () => 'tree',\n\t\t\tgetAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLevel!(node.element as T);\n\t\t\t}),\n\t\t\tgetActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getActiveDescendantId!(node.element as T);\n\t\t\t})\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\t...options.keyboardNavigationLabelProvider,\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tdefaultFindVisibility: e => {\n\t\t\tif (e.hasChildren && e.stale) {\n\t\t\t\treturn TreeVisibility.Visible;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'number') {\n\t\t\t\treturn options.defaultFindVisibility;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'undefined') {\n\t\t\t\treturn TreeVisibility.Recurse;\n\t\t\t} else {\n\t\t\t\treturn (options.defaultFindVisibility as ((e: T) => TreeVisibility))(e.element as T);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\nexport interface IAsyncDataTreeUpdateChildrenOptions<T> extends IObjectTreeSetChildrenOptions<T> { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, Pick<IAbstractTreeOptions<T, TFilterData>, Exclude<keyof IAbstractTreeOptions<T, TFilterData>, 'collapseByDefault'>> {\n\treadonly collapseByDefault?: { (e: T): boolean };\n\treadonly identityProvider?: IIdentityProvider<T>;\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly autoExpandSingleChildren?: boolean;\n\treadonly findResultsProvider?: IAsyncFindProvider<T>;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprotected readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprivate readonly model: IObjectTreeModel<IAsyncDataTreeNode<TInput, T> | null, TFilterData>;\n\tprotected readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\tprivate readonly findController?: AsyncFindController<TInput, T, TFilterData>;\n\tprivate readonly getDefaultCollapseState: { (e: T): undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded };\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, Promise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<Iterable<T>>>();\n\n\tprotected readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprotected readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n\n\tprotected readonly disposables = new DisposableStore();\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\n\tget onKeyDown(): Event<KeyboardEvent> { return this.tree.onKeyDown; }\n\tget onMouseClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onContextMenu(): Event<ITreeContextMenuEvent<T>> { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }\n\tget onTap(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onTap, asTreeMouseEvent); }\n\tget onPointer(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\tget onDidBlur(): Event<void> { return this.tree.onDidBlur; }\n\n\t/**\n\t * To be used internally only!\n\t * @deprecated\n\t */\n\tget onDidChangeModel(): Event<void> { return this.tree.onDidChangeModel; }\n\tget onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, TFilterData>> { return this.tree.onDidChangeCollapseState; }\n\n\tget onDidUpdateOptions(): Event<IAsyncDataTreeOptionsUpdate> { return this.tree.onDidUpdateOptions; }\n\n\treadonly onDidChangeFindOpenState: Event<boolean>;\n\tget onDidChangeStickyScrollFocused(): Event<boolean> { return this.tree.onDidChangeStickyScrollFocused; }\n\n\tget findMode(): TreeFindMode { return this.tree.findMode; }\n\tset findMode(mode: TreeFindMode) { this.tree.findMode = mode; }\n\treadonly onDidChangeFindMode: Event<TreeFindMode>;\n\n\tget findMatchType(): TreeFindMatchType { return this.tree.findMatchType; }\n\tset findMatchType(matchType: TreeFindMatchType) { this.tree.findMatchType = matchType; }\n\treadonly onDidChangeFindMatchType: Event<TreeFindMatchType>;\n\n\tget expandOnlyOnTwistieClick(): boolean | ((e: T) => boolean) {\n\t\tif (typeof this.tree.expandOnlyOnTwistieClick === 'boolean') {\n\t\t\treturn this.tree.expandOnlyOnTwistieClick;\n\t\t}\n\n\t\tconst fn = this.tree.expandOnlyOnTwistieClick;\n\t\treturn element => fn(this.nodes.get((element === this.root.element ? null : element) as T) || null);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tprotected user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\t\tthis.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n\n\t\tlet asyncFindEnabled = false;\n\t\tif (options.findResultsProvider && (options.findWidgetEnabled ?? true) && options.keyboardNavigationLabelProvider && options.contextViewProvider) {\n\t\t\tif (!this.dataSource.getParent || !this.identityProvider) {\n\t\t\t\tthrow new TreeError(this.user, 'Find Provider requires `getParent` and `identityProvider`');\n\t\t\t}\n\t\t\tasyncFindEnabled = true;\n\t\t}\n\n\t\tthis.tree = this.createTree(user, container, delegate, renderers, { ...options, findWidgetEnabled: !asyncFindEnabled });\n\t\tthis.model = this.tree.getModel() as IObjectTreeModel<IAsyncDataTreeNode<TInput, T> | null, TFilterData>;\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true,\n\t\t\tdefaultCollapseState: undefined\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\n\t\tif (asyncFindEnabled) {\n\t\t\tconst findFilter = this.disposables.add(new AsyncFindFilter<TInput, T>(this.tree.options.filter as ITreeFilter<IAsyncDataTreeNode<TInput, T>, FuzzyScore>));\n\t\t\tconst findOptions = { styles: options.findWidgetStyles, showNotFoundMessage: options.showNotFoundMessage };\n\t\t\tthis.findController = this.disposables.add(new AsyncFindController(user, this.tree, options.findResultsProvider!, findFilter!, this.sorter, this.dataSource, this.identityProvider!, options.contextViewProvider!, findOptions, node => this.asTreeElement(node)));\n\n\t\t\tthis.onDidChangeFindOpenState = this.findController!.onDidChangeOpenState;\n\t\t\tthis.onDidChangeFindMode = Event.None;\n\t\t\tthis.onDidChangeFindMatchType = Event.None;\n\t\t} else {\n\t\t\tthis.onDidChangeFindOpenState = this.tree.onDidChangeFindOpenState;\n\t\t\tthis.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n\t\t\tthis.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n\t\t}\n\t}\n\n\tprotected createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tupdateOptions(options: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\tget options(): IAsyncDataTreeOptions<T, TFilterData> {\n\t\treturn this.tree.options as IAsyncDataTreeOptions<T, TFilterData>;\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget contentHeight(): number {\n\t\treturn this.tree.contentHeight;\n\t}\n\n\tget contentWidth(): number {\n\t\treturn this.tree.contentWidth;\n\t}\n\n\tget onDidChangeContentHeight(): Event<number> {\n\t\treturn this.tree.onDidChangeContentHeight;\n\t}\n\n\tget onDidChangeContentWidth(): Event<number> {\n\t\treturn this.tree.onDidChangeContentWidth;\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollLeft(): number {\n\t\treturn this.tree.scrollLeft;\n\t}\n\n\tset scrollLeft(scrollLeft: number) {\n\t\tthis.tree.scrollLeft = scrollLeft;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tget lastVisibleElement(): T {\n\t\treturn this.tree.lastVisibleElement!.element as T;\n\t}\n\n\tget ariaLabel(): string {\n\t\treturn this.tree.ariaLabel;\n\t}\n\n\tset ariaLabel(value: string) {\n\t\tthis.tree.ariaLabel = value;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tisDOMFocused(): boolean {\n\t\treturn this.tree.isDOMFocused();\n\t}\n\n\tnavigate(start?: T) {\n\t\tlet startNode;\n\t\tif (start) {\n\t\t\tstartNode = this.getDataNode(start);\n\t\t}\n\t\treturn new AsyncDataTreeNavigator(this.tree.navigate(startNode));\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\n\t\tif (isNumber(width)) {\n\t\t\tthis.findController?.layout(width);\n\t\t}\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext: IAsyncDataTreeViewStateContext<TInput, T> | undefined = viewState && { viewState, focus: [], selection: [] };\n\n\t\tawait this._updateChildren(input, true, false, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tasync updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this._updateChildren(element, recursive, rerender, undefined, options);\n\t}\n\n\tprivate async _updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tawait this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n\t\tif (rerender) {\n\t\t\ttry {\n\t\t\t\tthis.tree.rerender(node);\n\t\t\t} catch {\n\t\t\t\t// missing nodes are fine, this could've resulted from\n\t\t\t\t// parallel refresh calls, removing `node` altogether\n\t\t\t}\n\t\t}\n\t}\n\n\tresort(element: TInput | T = this.root.element, recursive = true): void {\n\t\tthis.model.resort(this.getDataNode(element), recursive);\n\t}\n\n\thasNode(element: TInput | T): boolean {\n\t\treturn element === this.root.element || this.nodes.has(element as T);\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined || element === this.root.element) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\tupdateElementHeight(element: T, height: number | undefined): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateElementHeight(node, height);\n\t}\n\n\tupdateWidth(element: T): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateWidth(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn this.nodeMapper.map(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tif (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoggleCollapsed(element: T, recursive: boolean = false): boolean {\n\t\treturn this.tree.toggleCollapsed(this.getDataNode(element), recursive);\n\t}\n\n\texpandAll(): void {\n\t\tthis.tree.expandAll();\n\t}\n\n\tasync expandTo(element: T): Promise<void> {\n\t\tif (!this.dataSource.getParent) {\n\t\t\tthrow new Error('Can\\'t expand to element without getParent method');\n\t\t}\n\n\t\tconst elements: T[] = [];\n\n\t\twhile (!this.hasNode(element)) {\n\t\t\telement = this.dataSource.getParent(element) as T;\n\n\t\t\tif (element !== this.root.element) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\n\t\tfor (const element of Iterable.reverse(elements)) {\n\t\t\tawait this.expand(element);\n\t\t}\n\n\t\tthis.tree.expandTo(this.getDataNode(element));\n\t}\n\n\tcollapseAll(): void {\n\t\tthis.tree.collapseAll();\n\t}\n\n\tisCollapsible(element: T): boolean {\n\t\treturn this.tree.isCollapsible(this.getDataNode(element));\n\t}\n\n\tisCollapsed(element: TInput | T): boolean {\n\t\treturn this.tree.isCollapsed(this.getDataNode(element));\n\t}\n\n\ttriggerTypeNavigation(): void {\n\t\tthis.tree.triggerTypeNavigation();\n\t}\n\n\topenFind(): void {\n\t\tif (this.findController) {\n\t\t\tthis.findController.open();\n\t\t} else {\n\t\t\tthis.tree.openFind();\n\t\t}\n\t}\n\n\tcloseFind(): void {\n\t\tif (this.findController) {\n\t\t\tthis.findController.close();\n\t\t} else {\n\t\t\tthis.tree.closeFind();\n\t\t}\n\t}\n\n\trefilter(): void {\n\t\tthis.tree.refilter();\n\t}\n\n\tsetAnchor(element: T | undefined): void {\n\t\tthis.tree.setAnchor(typeof element === 'undefined' ? undefined : this.getDataNode(element));\n\t}\n\n\tgetAnchor(): T | undefined {\n\t\tconst node = this.tree.getAnchor();\n\t\treturn node?.element as T;\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tfocusNext(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusNext(n, loop, browserEvent);\n\t}\n\n\tfocusPrevious(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusPrevious(n, loop, browserEvent);\n\t}\n\n\tfocusNextPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusNextPage(browserEvent);\n\t}\n\n\tfocusPreviousPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusPreviousPage(browserEvent);\n\t}\n\n\tfocusLast(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusLast(browserEvent);\n\t}\n\n\tfocusFirst(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusFirst(browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetStickyScrollFocus(): T[] {\n\t\tconst nodes = this.tree.getStickyScrollFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetFocusedPart(): AbstractTreePart {\n\t\treturn this.tree.getFocusedPart();\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\tgetRelativeTop(element: T): number | null {\n\t\treturn this.tree.getRelativeTop(this.getDataNode(element));\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprotected getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst asyncFindNode: IAsyncDataTreeNode<TInput, T> | undefined = this.findController?.getDataNode(element);\n\n\t\tif (asyncFindNode) {\n\t\t\treturn asyncFindNode;\n\t\t}\n\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Data tree node not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh (#199264)\n\t\t}\n\t\tthis.render(node, viewStateContext, options);\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\n\t\t\tif (treeNode.collapsed) {\n\t\t\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\t\t\t\tnode.stale = true;\n\t\t\t\tthis.setChildren(node, [], recursive, viewStateContext);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn this.doRefreshSubTree(node, recursive, viewStateContext);\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet done: () => void;\n\t\tnode.refreshPromise = new Promise(c => done = c);\n\t\tthis.subTreeRefreshPromises.set(node, node.refreshPromise);\n\n\t\tnode.refreshPromise.finally(() => {\n\t\t\tnode.refreshPromise = undefined;\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t});\n\n\t\ttry {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t} finally {\n\t\t\tdone!();\n\t\t}\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n\t\tlet childrenPromise: Promise<Iterable<T>>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve(Iterable.empty());\n\t\t} else {\n\t\t\tconst children = this.doGetChildren(node);\n\t\t\tif (isIterable(children)) {\n\t\t\t\tchildrenPromise = Promise.resolve(children);\n\t\t\t} else {\n\t\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\t\tslowTimeout.then(() => {\n\t\t\t\t\tnode.slow = true;\n\t\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t\t}, _ => null);\n\n\t\t\t\tchildrenPromise = children.finally(() => slowTimeout.cancel());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root && this.model.has(node)) {\n\t\t\t\tthis.model.setCollapsed(node);\n\t\t\t}\n\n\t\t\tif (isCancellationError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<Iterable<T>> | Iterable<T> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tconst children = this.dataSource.getChildren(node.element);\n\t\tif (isIterable(children)) {\n\t\t\treturn this.processChildren(children);\n\t\t} else {\n\t\t\tresult = createCancelablePromise(async () => this.processChildren(await children));\n\t\t\tthis.refreshPromises.set(node, result);\n\t\t\treturn result.finally(() => { this.refreshPromises.delete(node); });\n\t\t}\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, any>): void {\n\t\tif (node.element === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElementsIterable: Iterable<T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\tconst childrenElements = [...childrenElementsIterable];\n\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, { node: IAsyncDataTreeNode<TInput, T>; collapsed: boolean }>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, { node: child, collapsed: this.model.has(child) && this.model.isCollapsed(child) });\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tconst hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\tif (!this.identityProvider) {\n\t\t\t\tconst asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\t\tif (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst result = childrenTreeNodesById.get(id);\n\n\t\t\tif (result) {\n\t\t\t\tconst asyncDataTreeNode = result.node;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = hasChildren;\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (result.collapsed) {\n\t\t\t\t\t\tasyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element as T)));\n\t\t\t\t\t\tasyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n\t\t\t\t\t\tasyncDataTreeNode.stale = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t} else if (hasChildren && !result.collapsed) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t} else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of nodesToForget.values()) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tnode.children.splice(0, node.children.length, ...children);\n\n\t\t// TODO@joao this doesn't take filter into account\n\t\tif (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n\t\t\tchildren[0].forceExpanded = true;\n\t\t\tchildrenToRefresh.push(children[0]);\n\t\t}\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprotected render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tconst children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n\t\tconst objectTreeOptions: IObjectTreeSetChildrenOptions<IAsyncDataTreeNode<TInput, T>> | undefined = options && {\n\t\t\t...options,\n\t\t\tdiffIdentityProvider: options.diffIdentityProvider && {\n\t\t\t\tgetId(node: IAsyncDataTreeNode<TInput, T>): { toString(): string } {\n\t\t\t\t\treturn options.diffIdentityProvider!.getId(node.element as T);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.model.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n\t\tif (node !== this.root) {\n\t\t\tthis.model.setCollapsible(node, node.hasChildren);\n\t\t}\n\n\t\tthis._onDidRender.fire();\n\t}\n\n\tprotected asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IObjectTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\tif (node.stale) {\n\t\t\treturn {\n\t\t\t\telement: node,\n\t\t\t\tcollapsible: node.hasChildren,\n\t\t\t\tcollapsed: true\n\t\t\t};\n\t\t}\n\n\t\tlet collapsed: boolean | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded | undefined;\n\n\t\tif (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n\t\t\tcollapsed = false;\n\t\t} else if (node.forceExpanded) {\n\t\t\tcollapsed = false;\n\t\t\tnode.forceExpanded = false;\n\t\t} else {\n\t\t\tcollapsed = node.defaultCollapseState;\n\t\t}\n\n\t\treturn {\n\t\t\telement: node,\n\t\t\tchildren: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n\t\t\tcollapsible: node.hasChildren,\n\t\t\tcollapsed\n\t\t};\n\t}\n\n\tprotected processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.sorter) {\n\t\t\tchildren = [...children].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn children;\n\t}\n\n\t// view state\n\n\tgetViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\texpanded.push(getId(node.element!.element as T));\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t\tthis.tree.dispose();\n\t}\n}\n\ntype CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>>;\n\nclass CompressibleAsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData> {\n\n\tget element(): ICompressedTreeNode<TInput | T> {\n\t\treturn {\n\t\t\telements: this.node.element.elements.map(e => e.element),\n\t\t\tincompressible: this.node.element.incompressible\n\t\t};\n\t}\n\n\tget children(): ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>[] { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>) { }\n}\n\nclass CompressibleAsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ICompressibleTreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprotected renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\tprivate compressibleNodeMapperProvider: () => CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nexport interface ITreeCompressionDelegate<T> {\n\tisIncompressible(element: T): boolean;\n}\n\nfunction asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options?: ICompressibleAsyncDataTreeOptions<T, TFilterData>): ICompressibleObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\tconst objectTreeOptions = options && asObjectTreeOptions(options);\n\n\treturn objectTreeOptions && {\n\t\t...objectTreeOptions,\n\t\tkeyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n\t\t\t...objectTreeOptions.keyboardNavigationLabelProvider,\n\t\t\tgetCompressedNodeKeyboardNavigationLabel(els) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element as T));\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptions<T, TFilterData> {\n\treadonly compressionEnabled?: boolean;\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nexport interface ICompressibleAsyncDataTreeOptionsUpdate extends IAsyncDataTreeOptionsUpdate {\n\treadonly compressionEnabled?: boolean;\n}\n\nexport class CompressibleAsyncDataTree<TInput, T, TFilterData = void> extends AsyncDataTree<TInput, T, TFilterData> {\n\n\tprotected declare readonly tree: CompressibleObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly compressibleNodeMapper: CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tvirtualDelegate: IListVirtualDelegate<T>,\n\t\tprivate compressionDelegate: ITreeCompressionDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\tdataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, virtualDelegate, renderers, dataSource, options);\n\t\tthis.filter = options.filter;\n\t}\n\n\tgetCompressedTreeNode(e: T | TInput) {\n\t\tconst node = this.getDataNode(e);\n\t\treturn this.tree.getCompressedTreeNode(node).element;\n\t}\n\n\tprotected override createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tprotected override asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ICompressedTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\treturn {\n\t\t\tincompressible: this.compressionDelegate.isIncompressible(node.element as T),\n\t\t\t...super.asTreeElement(node, viewStateContext)\n\t\t};\n\t}\n\n\toverride updateOptions(options: ICompressibleAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\toverride getViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getCompressedTreeNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\tfor (const asyncNode of node.element!.elements) {\n\t\t\t\t\texpanded.push(getId(asyncNode.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tprotected override render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tif (!this.identityProvider) {\n\t\t\treturn super.render(node, viewStateContext);\n\t\t}\n\n\t\t// Preserve traits across compressions. Hacky but does the trick.\n\t\t// This is hard to fix properly since it requires rewriting the traits\n\t\t// across trees and lists. Let's just keep it this way for now.\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst getUncompressedIds = (nodes: IAsyncDataTreeNode<TInput, T>[]): Set<string> => {\n\t\t\tconst result = new Set<string>();\n\n\t\t\tfor (const node of nodes) {\n\t\t\t\tconst compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n\t\t\t\tif (!compressedNode.element) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (const node of compressedNode.element.elements) {\n\t\t\t\t\tresult.add(getId(node.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst oldSelection = getUncompressedIds(this.tree.getSelection() as IAsyncDataTreeNode<TInput, T>[]);\n\t\tconst oldFocus = getUncompressedIds(this.tree.getFocus() as IAsyncDataTreeNode<TInput, T>[]);\n\n\t\tsuper.render(node, viewStateContext, options);\n\n\t\tconst selection = this.getSelection();\n\t\tlet didChangeSelection = false;\n\n\t\tconst focus = this.getFocus();\n\t\tlet didChangeFocus = false;\n\n\t\tconst visit = (node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>> | null, TFilterData>) => {\n\t\t\tconst compressedNode = node.element;\n\n\t\t\tif (compressedNode) {\n\t\t\t\tfor (let i = 0; i < compressedNode.elements.length; i++) {\n\t\t\t\t\tconst id = getId(compressedNode.elements[i].element as T);\n\t\t\t\t\tconst element = compressedNode.elements[compressedNode.elements.length - 1].element as T;\n\n\t\t\t\t\t// github.com/microsoft/vscode/issues/85938\n\t\t\t\t\tif (oldSelection.has(id) && selection.indexOf(element) === -1) {\n\t\t\t\t\t\tselection.push(element);\n\t\t\t\t\t\tdidChangeSelection = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (oldFocus.has(id) && focus.indexOf(element) === -1) {\n\t\t\t\t\t\tfocus.push(element);\n\t\t\t\t\t\tdidChangeFocus = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.children.forEach(visit);\n\t\t};\n\n\t\tvisit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n\t\tif (didChangeSelection) {\n\t\t\tthis.setSelection(selection);\n\t\t}\n\n\t\tif (didChangeFocus) {\n\t\t\tthis.setFocus(focus);\n\t\t}\n\t}\n\n\t// For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n\t// and we have to filter everything beforehand\n\t// Related to #85193 and #85835\n\tprotected override processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.filter) {\n\t\t\tchildren = Iterable.filter(children, e => {\n\t\t\t\tconst result = this.filter!.filter(e, TreeVisibility.Visible);\n\t\t\t\tconst visibility = getVisibility(result);\n\n\t\t\t\tif (visibility === TreeVisibility.Recurse) {\n\t\t\t\t\tthrow new Error('Recursive tree visibility not supported in async data compressed trees');\n\t\t\t\t}\n\n\t\t\t\treturn visibility === TreeVisibility.Visible;\n\t\t\t});\n\t\t}\n\n\t\treturn super.processChildren(children);\n\t}\n\n\toverride navigate(start?: T): AsyncDataTreeNavigator<TInput, T> {\n\t\t// Assumptions are made about how tree navigation works in compressed trees\n\t\t// These assumptions may be wrong and we should revisit this when needed\n\n\t\t// Example:\t[a, b/ba, ba.txt]\n\t\t// - previous(ba) => a\n\t\t// - previous(b) => a\n\t\t// - next(a) => ba\n\t\t// - next(b) => ba\n\t\t// - next(ba) => ba.txt\n\t\treturn super.navigate(start);\n\t}\n}\n\nfunction getVisibility<TFilterData>(filterResult: TreeFilterResult<TFilterData>): TreeVisibility {\n\tif (typeof filterResult === 'boolean') {\n\t\treturn filterResult ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t} else if (isFilterResult(filterResult)) {\n\t\treturn getVisibleState(filterResult.visibility);\n\t} else {\n\t\treturn getVisibleState(filterResult);\n\t}\n}\n\nclass AsyncDataTreeNavigator<TInput, T> implements ITreeNavigator<T> {\n\n\tconstructor(private navigator: ITreeNavigator<IAsyncDataTreeNode<TInput, T> | null>) { }\n\n\tcurrent(): T | null {\n\t\tconst current = this.navigator.current();\n\t\tif (current === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn current.element as T;\n\t}\n\n\tprevious(): T | null {\n\t\tthis.navigator.previous();\n\t\treturn this.current();\n\t}\n\n\tfirst(): T | null {\n\t\tthis.navigator.first();\n\t\treturn this.current();\n\t}\n\n\tlast(): T | null {\n\t\tthis.navigator.last();\n\t\treturn this.current();\n\t}\n\n\tnext(): T | null {\n\t\tthis.navigator.next();\n\t\treturn this.current();\n\t}\n}\n"],
  "mappings": "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",
  "names": ["e", "element", "node"]
}
