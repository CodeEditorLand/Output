import{CancellationTokenSource as p}from"./cancellation.js";import{BugIndicatingError as c,CancellationError as d}from"./errors.js";import{Emitter as T,Event as m}from"./event.js";import{Disposable as k,DisposableMap as _,MutableDisposable as g,toDisposable as v}from"./lifecycle.js";import{extUri as f}from"./resources.js";import"./uri.js";import{setTimeout0 as w}from"./platform.js";import{MicrotaskDelay as I}from"./symbols.js";import{Lazy as x}from"./lazy.js";function R(s){return!!s&&typeof s.then=="function"}function D(s){const e=new p,t=s(e.token),i=new Promise((r,n)=>{const o=e.token.onCancellationRequested(()=>{o.dispose(),n(new d)});Promise.resolve(t).then(a=>{o.dispose(),e.dispose(),r(a)},a=>{o.dispose(),e.dispose(),n(a)})});return new class{cancel(){e.cancel(),e.dispose()}then(r,n){return i.then(r,n)}catch(r){return this.then(void 0,r)}finally(r){return i.finally(r)}}}function ne(s,e,t){return new Promise((i,r)=>{const n=e.onCancellationRequested(()=>{n.dispose(),i(t)});s.then(i,r).finally(()=>n.dispose())})}function oe(s,e){return new Promise((t,i)=>{const r=e.onCancellationRequested(()=>{r.dispose(),i(new d)});s.then(t,i).finally(()=>r.dispose())})}async function ae(s){let e=-1;const t=s.map((i,r)=>i.then(n=>(e=r,n)));try{return await Promise.race(t)}finally{s.forEach((i,r)=>{r!==e&&i.cancel()})}}function le(s,e,t){let i;const r=setTimeout(()=>{i?.(void 0),t?.()},e);return Promise.race([s.finally(()=>clearTimeout(r)),new Promise(n=>i=n)])}function ue(s,e){return new Promise((t,i)=>{if(s.length===0){t(void 0);return}let r=!1,n=s.length;for(const o of s)o.then(a=>{n--,r||(e(a)?(r=!0,t(a)):n===0&&t(void 0))}).catch(i)})}function de(s){return new Promise((e,t)=>{const i=s();R(i)?i.then(e,t):e(i)})}function q(){let s,e;return{promise:new Promise((i,r)=>{s=i,e=r}),resolve:s,reject:e}}class C{activePromise;queuedPromise;queuedPromiseFactory;isDisposed=!1;constructor(){this.activePromise=null,this.queuedPromise=null,this.queuedPromiseFactory=null}queue(e){if(this.isDisposed)return Promise.reject(new Error("Throttler is disposed"));if(this.activePromise){if(this.queuedPromiseFactory=e,!this.queuedPromise){const t=()=>{if(this.queuedPromise=null,this.isDisposed)return;const i=this.queue(this.queuedPromiseFactory);return this.queuedPromiseFactory=null,i};this.queuedPromise=new Promise(i=>{this.activePromise.then(t,t).then(i)})}return new Promise((t,i)=>{this.queuedPromise.then(t,i)})}return this.activePromise=e(),new Promise((t,i)=>{this.activePromise.then(r=>{this.activePromise=null,t(r)},r=>{this.activePromise=null,i(r)})})}dispose(){this.isDisposed=!0}}class ce{current=Promise.resolve(null);queue(e){return this.current=this.current.then(()=>e(),()=>e())}}class he{promiseMap=new Map;queue(e,t){const r=(this.promiseMap.get(e)??Promise.resolve()).catch(()=>{}).then(t).finally(()=>{this.promiseMap.get(e)===r&&this.promiseMap.delete(e)});return this.promiseMap.set(e,r),r}}const S=(s,e)=>{let t=!0;const i=setTimeout(()=>{t=!1,e()},s);return{isTriggered:()=>t,dispose:()=>{clearTimeout(i),t=!1}}},E=s=>{let e=!0;return queueMicrotask(()=>{e&&(e=!1,s())}),{isTriggered:()=>e,dispose:()=>{e=!1}}};class O{constructor(e){this.defaultDelay=e;this.deferred=null,this.completionPromise=null,this.doResolve=null,this.doReject=null,this.task=null}deferred;completionPromise;doResolve;doReject;task;trigger(e,t=this.defaultDelay){this.task=e,this.cancelTimeout(),this.completionPromise||(this.completionPromise=new Promise((r,n)=>{this.doResolve=r,this.doReject=n}).then(()=>{if(this.completionPromise=null,this.doResolve=null,this.task){const r=this.task;return this.task=null,r()}}));const i=()=>{this.deferred=null,this.doResolve?.(null)};return this.deferred=t===I?E(i):S(t,i),this.completionPromise}isTriggered(){return!!this.deferred?.isTriggered()}cancel(){this.cancelTimeout(),this.completionPromise&&(this.doReject?.(new d),this.completionPromise=null)}cancelTimeout(){this.deferred?.dispose(),this.deferred=null}dispose(){this.cancel()}}class me{delayer;throttler;constructor(e){this.delayer=new O(e),this.throttler=new C}trigger(e,t){return this.delayer.trigger(()=>this.throttler.queue(e),t)}isTriggered(){return this.delayer.isTriggered()}cancel(){this.delayer.cancel()}dispose(){this.delayer.dispose(),this.throttler.dispose()}}class A{_isOpen;_promise;_completePromise;constructor(){this._isOpen=!1,this._promise=new Promise((e,t)=>{this._completePromise=e})}isOpen(){return this._isOpen}open(){this._isOpen=!0,this._completePromise(!0)}wait(){return this._promise}}class pe extends A{_timeout;constructor(e){super(),this._timeout=setTimeout(()=>this.open(),e)}open(){clearTimeout(this._timeout),super.open()}}function P(s,e){return e?new Promise((t,i)=>{const r=setTimeout(()=>{n.dispose(),t()},s),n=e.onCancellationRequested(()=>{clearTimeout(r),n.dispose(),i(new d)})}):D(t=>P(s,t))}function Te(s,e=0,t){const i=setTimeout(()=>{s(),t&&r.dispose()},e),r=v(()=>{clearTimeout(i),t?.deleteAndLeak(r)});return t?.add(r),r}function ve(s){const e=[];let t=0;const i=s.length;function r(){return t<i?s[t++]():null}function n(o){o!=null&&e.push(o);const a=r();return a?a.then(n):Promise.resolve(e)}return Promise.resolve(null).then(n)}function fe(s,e=i=>!!i,t=null){let i=0;const r=s.length,n=()=>{if(i>=r)return Promise.resolve(t);const o=s[i++];return Promise.resolve(o()).then(u=>e(u)?Promise.resolve(u):n())};return n()}function Pe(s,e=i=>!!i,t=null){if(s.length===0)return Promise.resolve(t);let i=s.length;const r=()=>{i=-1;for(const n of s)n.cancel?.()};return new Promise((n,o)=>{for(const a of s)a.then(u=>{--i>=0&&e(u)?(r(),n(u)):i===0&&n(t)}).catch(u=>{--i>=0&&(r(),o(u))})})}class j{_size=0;_isDisposed=!1;runningPromises;maxDegreeOfParalellism;outstandingPromises;_onDrained;constructor(e){this.maxDegreeOfParalellism=e,this.outstandingPromises=[],this.runningPromises=0,this._onDrained=new T}whenIdle(){return this.size>0?m.toPromise(this.onDrained):Promise.resolve()}get onDrained(){return this._onDrained.event}get size(){return this._size}queue(e){if(this._isDisposed)throw new Error("Object has been disposed");return this._size++,new Promise((t,i)=>{this.outstandingPromises.push({factory:e,c:t,e:i}),this.consume()})}consume(){for(;this.outstandingPromises.length&&this.runningPromises<this.maxDegreeOfParalellism;){const e=this.outstandingPromises.shift();this.runningPromises++;const t=e.factory();t.then(e.c,e.e),t.then(()=>this.consumed(),()=>this.consumed())}}consumed(){this._isDisposed||(this.runningPromises--,--this._size===0&&this._onDrained.fire(),this.outstandingPromises.length>0&&this.consume())}clear(){if(this._isDisposed)throw new Error("Object has been disposed");this.outstandingPromises.length=0,this._size=this.runningPromises}dispose(){this._isDisposed=!0,this.outstandingPromises.length=0,this._size=0,this._onDrained.dispose()}}class z extends j{constructor(){super(1)}}class be{sequentializer=new M;tasks=0;queue(e){return this.sequentializer.isRunning()?this.sequentializer.queue(()=>this.sequentializer.run(this.tasks++,e())):this.sequentializer.run(this.tasks++,e())}}class ye{queues=new Map;drainers=new Set;drainListeners=void 0;drainListenerCount=0;async whenDrained(){if(this.isDrained())return;const e=new y;return this.drainers.add(e),e.p}isDrained(){for(const[,e]of this.queues)if(e.size>0)return!1;return!0}queueSize(e,t=f){const i=t.getComparisonKey(e);return this.queues.get(i)?.size??0}queueFor(e,t,i=f){const r=i.getComparisonKey(e);let n=this.queues.get(r);if(!n){n=new z;const o=this.drainListenerCount++,a=m.once(n.onDrained)(()=>{n?.dispose(),this.queues.delete(r),this.onDidQueueDrain(),this.drainListeners?.deleteAndDispose(o),this.drainListeners?.size===0&&(this.drainListeners.dispose(),this.drainListeners=void 0)});this.drainListeners||(this.drainListeners=new _),this.drainListeners.set(o,a),this.queues.set(r,n)}return n.queue(t)}onDidQueueDrain(){this.isDrained()&&this.releaseDrainers()}releaseDrainers(){for(const e of this.drainers)e.complete();this.drainers.clear()}dispose(){for(const[,e]of this.queues)e.dispose();this.queues.clear(),this.releaseDrainers(),this.drainListeners?.dispose()}}class ke{_token;_isDisposed=!1;constructor(e,t){this._token=-1,typeof e=="function"&&typeof t=="number"&&this.setIfNotSet(e,t)}dispose(){this.cancel(),this._isDisposed=!0}cancel(){this._token!==-1&&(clearTimeout(this._token),this._token=-1)}cancelAndSet(e,t){if(this._isDisposed)throw new c("Calling 'cancelAndSet' on a disposed TimeoutTimer");this.cancel(),this._token=setTimeout(()=>{this._token=-1,e()},t)}setIfNotSet(e,t){if(this._isDisposed)throw new c("Calling 'setIfNotSet' on a disposed TimeoutTimer");this._token===-1&&(this._token=setTimeout(()=>{this._token=-1,e()},t))}}class _e{disposable=void 0;isDisposed=!1;cancel(){this.disposable?.dispose(),this.disposable=void 0}cancelAndSet(e,t,i=globalThis){if(this.isDisposed)throw new c("Calling 'cancelAndSet' on a disposed IntervalTimer");this.cancel();const r=i.setInterval(()=>{e()},t);this.disposable=v(()=>{i.clearInterval(r),this.disposable=void 0})}dispose(){this.cancel(),this.isDisposed=!0}}class b{runner;timeoutToken;timeout;timeoutHandler;constructor(e,t){this.timeoutToken=-1,this.runner=e,this.timeout=t,this.timeoutHandler=this.onTimeout.bind(this)}dispose(){this.cancel(),this.runner=null}cancel(){this.isScheduled()&&(clearTimeout(this.timeoutToken),this.timeoutToken=-1)}schedule(e=this.timeout){this.cancel(),this.timeoutToken=setTimeout(this.timeoutHandler,e)}get delay(){return this.timeout}set delay(e){this.timeout=e}isScheduled(){return this.timeoutToken!==-1}flush(){this.isScheduled()&&(this.cancel(),this.doRun())}onTimeout(){this.timeoutToken=-1,this.runner&&this.doRun()}doRun(){this.runner?.()}}class ge{runner;timeout;counter;intervalToken;intervalHandler;constructor(e,t){t%1e3,this.runner=e,this.timeout=t,this.counter=0,this.intervalToken=-1,this.intervalHandler=this.onInterval.bind(this)}dispose(){this.cancel(),this.runner=null}cancel(){this.isScheduled()&&(clearInterval(this.intervalToken),this.intervalToken=-1)}schedule(e=this.timeout){e%1e3,this.cancel(),this.counter=Math.ceil(e/1e3),this.intervalToken=setInterval(this.intervalHandler,1e3)}isScheduled(){return this.intervalToken!==-1}onInterval(){this.counter--,!(this.counter>0)&&(clearInterval(this.intervalToken),this.intervalToken=-1,this.runner?.())}}class we extends b{units=[];constructor(e,t){super(e,t)}work(e){this.units.push(e),this.isScheduled()||this.schedule()}doRun(){const e=this.units;this.units=[],this.runner?.(e)}dispose(){this.units=[],super.dispose()}}class Ie extends k{constructor(t,i){super();this.options=t;this.handler=i}pendingWork=[];throttler=this._register(new g);disposed=!1;lastExecutionTime=0;get pending(){return this.pendingWork.length}work(t){if(this.disposed)return!1;if(typeof this.options.maxBufferedWork=="number"){if(this.throttler.value){if(this.pending+t.length>this.options.maxBufferedWork)return!1}else if(this.pending+t.length-this.options.maxWorkChunkSize>this.options.maxBufferedWork)return!1}for(const r of t)this.pendingWork.push(r);const i=Date.now()-this.lastExecutionTime;return!this.throttler.value&&(!this.options.waitThrottleDelayBetweenWorkUnits||i>=this.options.throttleDelay)?this.doWork():!this.throttler.value&&this.options.waitThrottleDelayBetweenWorkUnits&&this.scheduleThrottler(Math.max(this.options.throttleDelay-i,0)),!0}doWork(){this.lastExecutionTime=Date.now(),this.handler(this.pendingWork.splice(0,this.options.maxWorkChunkSize)),this.pendingWork.length>0&&this.scheduleThrottler()}scheduleThrottler(t=this.options.throttleDelay){this.throttler.value=new b(()=>{this.throttler.clear(),this.doWork()},t),this.throttler.value.schedule()}dispose(){super.dispose(),this.disposed=!0}}let W,h;(function(){typeof globalThis.requestIdleCallback!="function"||typeof globalThis.cancelIdleCallback!="function"?h=(s,e,t)=>{w(()=>{if(i)return;const r=Date.now()+15;e(Object.freeze({didTimeout:!0,timeRemaining(){return Math.max(0,r-Date.now())}}))});let i=!1;return{dispose(){i||(i=!0)}}}:h=(s,e,t)=>{const i=s.requestIdleCallback(e,typeof t=="number"?{timeout:t}:void 0);let r=!1;return{dispose(){r||(r=!0,s.cancelIdleCallback(i))}}},W=(s,e)=>h(globalThis,s,e)})();class L{_executor;_handle;_didRun=!1;_value;_error;constructor(e,t){this._executor=()=>{try{this._value=t()}catch(i){this._error=i}finally{this._didRun=!0}},this._handle=h(e,()=>this._executor())}dispose(){this._handle.dispose()}get value(){if(this._didRun||(this._handle.dispose(),this._executor()),this._error)throw this._error;return this._value}get isInitialized(){return this._didRun}}class xe extends L{constructor(e){super(globalThis,e)}}async function Re(s,e,t){let i;for(let r=0;r<t;r++)try{return await s()}catch(n){i=n,await P(e)}throw i}class M{_running;_queued;isRunning(e){return typeof e=="number"?this._running?.taskId===e:!!this._running}get running(){return this._running?.promise}cancelRunning(){this._running?.cancel()}run(e,t,i){return this._running={taskId:e,cancel:()=>i?.(),promise:t},t.then(()=>this.doneRunning(e),()=>this.doneRunning(e)),t}doneRunning(e){this._running&&e===this._running.taskId&&(this._running=void 0,this.runQueued())}runQueued(){if(this._queued){const e=this._queued;this._queued=void 0,e.run().then(e.promiseResolve,e.promiseReject)}}queue(e){if(this._queued)this._queued.run=e;else{const{promise:t,resolve:i,reject:r}=q();this._queued={run:e,promise:t,promiseResolve:i,promiseReject:r}}return this._queued.promise}hasQueued(){return!!this._queued}async join(){return this._queued?.promise??this._running?.promise}}class De{constructor(e,t=()=>Date.now()){this.interval=e;this.nowFn=t}lastIncrementTime=0;value=0;increment(){const e=this.nowFn();return e-this.lastIncrementTime>this.interval&&(this.lastIncrementTime=e,this.value=0),this.value++,this.value}}var F=(t=>(t[t.Resolved=0]="Resolved",t[t.Rejected=1]="Rejected",t))(F||{});class y{completeCallback;errorCallback;outcome;get isRejected(){return this.outcome?.outcome===1}get isResolved(){return this.outcome?.outcome===0}get isSettled(){return!!this.outcome}get value(){return this.outcome?.outcome===0?this.outcome?.value:void 0}p;constructor(){this.p=new Promise((e,t)=>{this.completeCallback=e,this.errorCallback=t})}complete(e){return new Promise(t=>{this.completeCallback(e),this.outcome={outcome:0,value:e},t()})}error(e){return new Promise(t=>{this.errorCallback(e),this.outcome={outcome:1,value:e},t()})}cancel(){return this.error(new d)}}var Q;(t=>{async function s(i){let r;const n=await Promise.all(i.map(o=>o.then(a=>a,a=>{r||(r=a)})));if(typeof r<"u")throw r;return n}t.settled=s;function e(i){return new Promise(async(r,n)=>{try{await i(r,n)}catch(o){n(o)}})}t.withAsyncBody=e})(Q||={});class B{_value=void 0;get value(){return this._value}_error=void 0;get error(){return this._error}_isResolved=!1;get isResolved(){return this._isResolved}promise;constructor(e){this.promise=e.then(t=>(this._value=t,this._isResolved=!0,t),t=>{throw this._error=t,this._isResolved=!0,t})}requireValue(){if(!this._isResolved)throw new c("Promise is not resolved yet");if(this._error)throw this._error;return this._value}}class qe{constructor(e){this._compute=e}_promise=new x(()=>new B(this._compute()));requireValue(){return this._promise.value.requireValue()}getPromise(){return this._promise.value.promise}get currentValue(){return this._promise.rawValue?.value}}var U=(i=>(i[i.Initial=0]="Initial",i[i.DoneOK=1]="DoneOK",i[i.DoneError=2]="DoneError",i))(U||{});class l{static fromArray(e){return new l(t=>{t.emitMany(e)})}static fromPromise(e){return new l(async t=>{t.emitMany(await e)})}static fromPromisesResolveOrder(e){return new l(async t=>{await Promise.all(e.map(async i=>t.emitOne(await i)))})}static merge(e){return new l(async t=>{await Promise.all(e.map(async i=>{for await(const r of i)t.emitOne(r)}))})}static EMPTY=l.fromArray([]);_state;_results;_error;_onReturn;_onStateChanged;constructor(e,t){this._state=0,this._results=[],this._error=null,this._onReturn=t,this._onStateChanged=new T,queueMicrotask(async()=>{const i={emitOne:r=>this.emitOne(r),emitMany:r=>this.emitMany(r),reject:r=>this.reject(r)};try{await Promise.resolve(e(i)),this.resolve()}catch(r){this.reject(r)}finally{i.emitOne=void 0,i.emitMany=void 0,i.reject=void 0}})}[Symbol.asyncIterator](){let e=0;return{next:async()=>{do{if(this._state===2)throw this._error;if(e<this._results.length)return{done:!1,value:this._results[e++]};if(this._state===1)return{done:!0,value:void 0};await m.toPromise(this._onStateChanged.event)}while(!0)},return:async()=>(this._onReturn?.(),{done:!0,value:void 0})}}static map(e,t){return new l(async i=>{for await(const r of e)i.emitOne(t(r))})}map(e){return l.map(this,e)}static filter(e,t){return new l(async i=>{for await(const r of e)t(r)&&i.emitOne(r)})}filter(e){return l.filter(this,e)}static coalesce(e){return l.filter(e,t=>!!t)}coalesce(){return l.coalesce(this)}static async toPromise(e){const t=[];for await(const i of e)t.push(i);return t}toPromise(){return l.toPromise(this)}emitOne(e){this._state===0&&(this._results.push(e),this._onStateChanged.fire())}emitMany(e){this._state===0&&(this._results=this._results.concat(e),this._onStateChanged.fire())}resolve(){this._state===0&&(this._state=1,this._onStateChanged.fire())}reject(e){this._state===0&&(this._state=2,this._error=e,this._onStateChanged.fire())}}class V extends l{constructor(t,i){super(i);this._source=t}cancel(){this._source.cancel()}}function Ce(s){const e=new p,t=s(e.token);return new V(e,async i=>{const r=e.token.onCancellationRequested(()=>{r.dispose(),e.dispose(),i.reject(new d)});try{for await(const n of t){if(e.token.isCancellationRequested)return;i.emitOne(n)}r.dispose(),e.dispose()}catch(n){r.dispose(),e.dispose(),i.reject(n)}})}class Se{_deferred=new y;_asyncIterable;_errorFn;_emitFn;constructor(e){this._asyncIterable=new l(r=>{if(t){r.reject(t);return}return i&&r.emitMany(i),this._errorFn=n=>r.reject(n),this._emitFn=n=>r.emitOne(n),this._deferred.p},e);let t,i;this._emitFn=r=>{i||(i=[]),i.push(r)},this._errorFn=r=>{t||(t=r)}}get asyncIterable(){return this._asyncIterable}resolve(){this._deferred.complete()}reject(e){this._errorFn(e),this._deferred.complete()}emitOne(e){this._emitFn(e)}}export{L as AbstractIdleValue,l as AsyncIterableObject,Se as AsyncIterableSource,pe as AutoOpenBarrier,A as Barrier,V as CancelableAsyncIterableObject,y as DeferredPromise,O as Delayer,xe as GlobalIdleValue,De as IntervalCounter,_e as IntervalTimer,qe as LazyStatefulPromise,be as LimitedQueue,j as Limiter,ge as ProcessTimeRunOnceScheduler,Q as Promises,z as Queue,ye as ResourceQueue,b as RunOnceScheduler,we as RunOnceWorker,ce as Sequencer,he as SequencerByKey,B as StatefulPromise,M as TaskSequentializer,me as ThrottledDelayer,Ie as ThrottledWorker,C as Throttler,ke as TimeoutTimer,h as _runWhenIdle,de as asPromise,Ce as createCancelableAsyncIterable,D as createCancelablePromise,Te as disposableTimeout,fe as first,Pe as firstParallel,R as isThenable,q as promiseWithResolvers,ae as raceCancellablePromises,ne as raceCancellation,oe as raceCancellationError,ue as raceFilter,le as raceTimeout,Re as retry,W as runWhenGlobalIdle,ve as sequence,P as timeout};
