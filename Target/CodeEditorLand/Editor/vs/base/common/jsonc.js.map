{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/Land/Dependency/Editor/Source/vs/base/common/jsonc.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// First group matches a double quoted string\n// Second group matches a single quoted string\n// Third group matches a multi line comment\n// Forth group matches a single line comment\n// Fifth group matches a trailing comma\nconst regexp = /(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\\/\\*[^\\/\\*]*(?:(?:\\*|\\/)[^\\/\\*]*)*?\\*\\/)|(\\/{2,}.*?(?:(?:\\r?\\n)|$))|(,\\s*[}\\]])/g;\n\n/**\n * Strips single and multi line JavaScript comments from JSON\n * content. Ignores characters in strings BUT doesn't support\n * string continuation across multiple lines since it is not\n * supported in JSON.\n *\n * @param content the content to strip comments from\n * @returns the content without comments\n*/\nexport function stripComments(content: string): string {\n\treturn content.replace(regexp, function (match, _m1, _m2, m3, m4, m5) {\n\t\t// Only one of m1, m2, m3, m4, m5 matches\n\t\tif (m3) {\n\t\t\t// A block comment. Replace with nothing\n\t\t\treturn '';\n\t\t} else if (m4) {\n\t\t\t// Since m4 is a single line comment is is at least of length 2 (e.g. //)\n\t\t\t// If it ends in \\r?\\n then keep it.\n\t\t\tconst length = m4.length;\n\t\t\tif (m4[length - 1] === '\\n') {\n\t\t\t\treturn m4[length - 2] === '\\r' ? '\\r\\n' : '\\n';\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (m5) {\n\t\t\t// Remove the trailing comma\n\t\t\treturn match.substring(1);\n\t\t} else {\n\t\t\t// We match a string\n\t\t\treturn match;\n\t\t}\n\t});\n}\n\n/**\n * A drop-in replacement for JSON.parse that can parse\n * JSON with comments and trailing commas.\n *\n * @param content the content to strip comments from\n * @returns the parsed content as JSON\n*/\nexport function parse<T>(content: string): T {\n\tconst commentsStripped = stripComments(content);\n\n\ttry {\n\t\treturn JSON.parse(commentsStripped);\n\t} catch (error) {\n\t\tconst trailingCommasStriped = commentsStripped.replace(/,\\s*([}\\]])/g, '$1');\n\t\treturn JSON.parse(trailingCommasStriped);\n\t}\n}\n"],
  "mappings": ";;AAUA,MAAM,SAAS;AAWR,SAAS,cAAc,SAAyB;AACtD,SAAO,QAAQ,QAAQ,QAAQ,SAAU,OAAO,KAAK,KAAK,IAAI,IAAI,IAAI;AAErE,QAAI,IAAI;AAEP,aAAO;AAAA,IACR,WAAW,IAAI;AAGd,YAAM,SAAS,GAAG;AAClB,UAAI,GAAG,SAAS,CAAC,MAAM,MAAM;AAC5B,eAAO,GAAG,SAAS,CAAC,MAAM,OAAO,SAAS;AAAA,MAC3C,OACK;AACJ,eAAO;AAAA,MACR;AAAA,IACD,WAAW,IAAI;AAEd,aAAO,MAAM,UAAU,CAAC;AAAA,IACzB,OAAO;AAEN,aAAO;AAAA,IACR;AAAA,EACD,CAAC;AACF;AAxBgB;AAiCT,SAAS,MAAS,SAAoB;AAC5C,QAAM,mBAAmB,cAAc,OAAO;AAE9C,MAAI;AACH,WAAO,KAAK,MAAM,gBAAgB;AAAA,EACnC,SAAS,OAAO;AACf,UAAM,wBAAwB,iBAAiB,QAAQ,gBAAgB,IAAI;AAC3E,WAAO,KAAK,MAAM,qBAAqB;AAAA,EACxC;AACD;AATgB;",
  "names": []
}
