import"./base.js";import{DebugNameData as d}from"./debugName.js";import{assertFn as p,BugIndicatingError as l,DisposableStore as o,markAsDisposed as b,onBugIndicatingError as h,toDisposable as m,trackDisposable as y}from"./commonFacade/deps.js";import{getLogger as u}from"./logging.js";function g(a){return new s(new d(void 0,void 0,a),a,void 0,void 0)}function c(a,e){return new s(new d(a.owner,a.debugName,a.debugReferenceFn??e),e,void 0,void 0)}function C(a,e){return new s(new d(a.owner,a.debugName,a.debugReferenceFn??e),e,a.createEmptyChangeSummary,a.handleChange)}function _(a,e){const n=new o,t=C({owner:a.owner,debugName:a.debugName,debugReferenceFn:a.debugReferenceFn??e,createEmptyChangeSummary:a.createEmptyChangeSummary,handleChange:a.handleChange},(r,i)=>{n.clear(),e(r,i,n)});return m(()=>{t.dispose(),n.dispose()})}function A(a){const e=new o,n=c({owner:void 0,debugName:void 0,debugReferenceFn:a},t=>{e.clear(),a(t,e)});return m(()=>{n.dispose(),e.dispose()})}function B(a,e){let n;return c({debugReferenceFn:e},t=>{const r=a.read(t),i=n;n=r,e({lastValue:i,newValue:r})})}var f=(t=>(t[t.dependenciesMightHaveChanged=1]="dependenciesMightHaveChanged",t[t.stale=2]="stale",t[t.upToDate=3]="upToDate",t))(f||{});class s{constructor(e,n,t,r){this._debugNameData=e;this._runFn=n;this.createChangeSummary=t;this._handleChange=r;this.changeSummary=this.createChangeSummary?.(),u()?.handleAutorunCreated(this),this._runIfNeeded(),y(this)}state=2;updateCount=0;disposed=!1;dependencies=new Set;dependenciesToBeRemoved=new Set;changeSummary;get debugName(){return this._debugNameData.getDebugName(this)??"(anonymous)"}dispose(){this.disposed=!0;for(const e of this.dependencies)e.removeObserver(this);this.dependencies.clear(),b(this)}_runIfNeeded(){if(this.state===3)return;const e=this.dependenciesToBeRemoved;this.dependenciesToBeRemoved=this.dependencies,this.dependencies=e,this.state=3;const n=this.disposed;try{if(!n){u()?.handleAutorunTriggered(this);const t=this.changeSummary;try{this.changeSummary=this.createChangeSummary?.(),this._isReaderValid=!0,this._runFn(this,t)}catch(r){h(r)}finally{this._isReaderValid=!1}}}finally{n||u()?.handleAutorunFinished(this);for(const t of this.dependenciesToBeRemoved)t.removeObserver(this);this.dependenciesToBeRemoved.clear()}}toString(){return`Autorun<${this.debugName}>`}beginUpdate(){this.state===3&&(this.state=1),this.updateCount++}endUpdate(){try{if(this.updateCount===1)do{if(this.state===1){this.state=3;for(const e of this.dependencies)if(e.reportChanges(),this.state===2)break}this._runIfNeeded()}while(this.state!==3)}finally{this.updateCount--}p(()=>this.updateCount>=0)}handlePossibleChange(e){this.state===3&&this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)&&(this.state=1)}handleChange(e,n){if(this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e))try{(this._handleChange?this._handleChange({changedObservable:e,change:n,didChange:r=>r===e},this.changeSummary):!0)&&(this.state=2)}catch(t){h(t)}}_isReaderValid=!1;readObservable(e){if(!this._isReaderValid)throw new l("The reader object cannot be used outside its compute function!");if(this.disposed)return e.get();e.addObserver(this);const n=e.get();return this.dependencies.add(e),this.dependenciesToBeRemoved.delete(e),n}}(e=>e.Observer=s)(g||={});export{s as AutorunObserver,g as autorun,B as autorunDelta,C as autorunHandleChanges,c as autorunOpts,A as autorunWithStore,_ as autorunWithStoreHandleChanges};
