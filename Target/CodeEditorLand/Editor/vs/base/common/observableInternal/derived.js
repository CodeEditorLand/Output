import{BaseObservable as b,_setDerivedOpts as c}from"./base.js";import{DebugNameData as s}from"./debugName.js";import{BugIndicatingError as l,DisposableStore as p,assertFn as f,onBugIndicatingError as v,strictEquals as o}from"./commonFacade/deps.js";import{getLogger as m}from"./logging.js";function L(n,r){return r!==void 0?new u(new s(n,void 0,r),r,void 0,void 0,void 0,o):new u(new s(void 0,void 0,n),n,void 0,void 0,void 0,o)}function H(n,r,e){return new C(new s(n,void 0,r),r,void 0,void 0,void 0,o,e)}function g(n,r){return new u(new s(n.owner,n.debugName,n.debugReferenceFn),r,void 0,void 0,n.onLastObserverRemoved,n.equalsFn??o)}c(g);function F(n,r){return new u(new s(n.owner,n.debugName,void 0),r,n.createEmptyChangeSummary,n.handleChange,void 0,n.equalityComparer??o)}function M(n,r){let e,a;r===void 0?(e=n,a=void 0):(a=n,e=r);const t=new p;return new u(new s(a,void 0,e),d=>(t.clear(),e(d,t)),void 0,void 0,()=>t.dispose(),o)}function W(n,r){let e,a;r===void 0?(e=n,a=void 0):(a=n,e=r);let t;return new u(new s(a,void 0,e),d=>{t?t.clear():t=new p;const i=e(d);return i&&t.add(i),i},void 0,void 0,()=>{t&&(t.dispose(),t=void 0)},o)}var T=(t=>(t[t.initial=0]="initial",t[t.dependenciesMightHaveChanged=1]="dependenciesMightHaveChanged",t[t.stale=2]="stale",t[t.upToDate=3]="upToDate",t))(T||{});class u extends b{constructor(e,a,t,d,i=void 0,h){super();this._debugNameData=e;this._computeFn=a;this.createChangeSummary=t;this._handleChange=d;this._handleLastObserverRemoved=i;this._equalityComparator=h;this.changeSummary=this.createChangeSummary?.(),m()?.handleDerivedCreated(this)}state=0;value=void 0;updateCount=0;dependencies=new Set;dependenciesToBeRemoved=new Set;changeSummary=void 0;_isUpdating=!1;_isComputing=!1;get debugName(){return this._debugNameData.getDebugName(this)??"(anonymous)"}onLastObserverRemoved(){this.state=0,this.value=void 0;for(const e of this.dependencies)e.removeObserver(this);this.dependencies.clear(),this._handleLastObserverRemoved?.()}get(){if(this._isComputing)throw new l("Cyclic deriveds are not supported yet!");if(this.observers.size===0){let e;try{this._isReaderValid=!0,e=this._computeFn(this,this.createChangeSummary?.())}finally{this._isReaderValid=!1}return this.onLastObserverRemoved(),e}else{do{if(this.state===1){for(const e of this.dependencies)if(e.reportChanges(),this.state===2)break}this.state===1&&(this.state=3),this._recomputeIfNeeded()}while(this.state!==3);return this.value}}_recomputeIfNeeded(){if(this.state===3)return;const e=this.dependenciesToBeRemoved;this.dependenciesToBeRemoved=this.dependencies,this.dependencies=e;const a=this.state!==0,t=this.value;this.state=3;let d=!1;this._isComputing=!0;try{const i=this.changeSummary;this.changeSummary=this.createChangeSummary?.();try{this._isReaderValid=!0,this.value=this._computeFn(this,i)}finally{this._isReaderValid=!1;for(const h of this.dependenciesToBeRemoved)h.removeObserver(this);this.dependenciesToBeRemoved.clear()}d=a&&!this._equalityComparator(t,this.value),m()?.handleDerivedRecomputed(this,{oldValue:t,newValue:this.value,change:void 0,didChange:d,hadValue:a})}catch(i){v(i)}if(this._isComputing=!1,d)for(const i of this.observers)i.handleChange(this,void 0)}toString(){return`LazyDerived<${this.debugName}>`}beginUpdate(e){if(this._isUpdating)throw new l("Cyclic deriveds are not supported yet!");this.updateCount++,this._isUpdating=!0;try{const a=this.updateCount===1;if(this.state===3&&(this.state=1,!a))for(const t of this.observers)t.handlePossibleChange(this);if(a)for(const t of this.observers)t.beginUpdate(this)}finally{this._isUpdating=!1}}endUpdate(e){if(this.updateCount--,this.updateCount===0){const a=[...this.observers];for(const t of a)t.endUpdate(this)}f(()=>this.updateCount>=0)}handlePossibleChange(e){if(this.state===3&&this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)){this.state=1;for(const a of this.observers)a.handlePossibleChange(this)}}handleChange(e,a){if(this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)){let t=!1;try{t=this._handleChange?this._handleChange({changedObservable:e,change:a,didChange:i=>i===e},this.changeSummary):!0}catch(i){v(i)}const d=this.state===3;if(t&&(this.state===1||d)&&(this.state=2,d))for(const i of this.observers)i.handlePossibleChange(this)}}_isReaderValid=!1;readObservable(e){if(!this._isReaderValid)throw new l("The reader object cannot be used outside its compute function!");e.addObserver(this);const a=e.get();return this.dependencies.add(e),this.dependenciesToBeRemoved.delete(e),a}addObserver(e){const a=!this.observers.has(e)&&this.updateCount>0;super.addObserver(e),a&&e.beginUpdate(this)}removeObserver(e){const a=this.observers.has(e)&&this.updateCount>0;super.removeObserver(e),a&&e.endUpdate(this)}}class C extends u{constructor(e,a,t,d,i=void 0,h,y){super(e,a,t,d,i,h);this.set=y}}export{u as Derived,C as DerivedWithSetter,L as derived,W as derivedDisposable,F as derivedHandleChanges,g as derivedOpts,H as derivedWithSetter,M as derivedWithStore};
