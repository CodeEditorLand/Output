{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/Land/Dependency/Editor/Source/vs/base/node/nls.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as perf from '../common/performance.js';\nimport type { ILanguagePacks, INLSConfiguration } from '../../nls.js';\n\nexport interface IResolveNLSConfigurationContext {\n\n\t/**\n\t * Location where `nls.messages.json` and `nls.keys.json` are stored.\n\t */\n\treadonly nlsMetadataPath: string;\n\n\t/**\n\t * Path to the user data directory. Used as a cache for\n\t * language packs converted to the format we need.\n\t */\n\treadonly userDataPath: string;\n\n\t/**\n\t * Commit of the running application. Can be `undefined`\n\t * when not built.\n\t */\n\treadonly commit: string | undefined;\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n}\n\nexport async function resolveNLSConfiguration({ userLocale, osLocale, userDataPath, commit, nlsMetadataPath }: IResolveNLSConfigurationContext): Promise<INLSConfiguration> {\n\tperf.mark('code/willGenerateNls');\n\n\tif (\n\t\tprocess.env['VSCODE_DEV'] ||\n\t\tuserLocale === 'pseudo' ||\n\t\tuserLocale.startsWith('en') ||\n\t\t!commit ||\n\t\t!userDataPath\n\t) {\n\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t}\n\n\ttry {\n\t\tconst languagePacks = await getLanguagePackConfigurations(userDataPath);\n\t\tif (!languagePacks) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst resolvedLanguage = resolveLanguagePackLanguage(languagePacks, userLocale);\n\t\tif (!resolvedLanguage) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePack = languagePacks[resolvedLanguage];\n\t\tconst mainLanguagePackPath = languagePack?.translations?.['vscode'];\n\t\tif (\n\t\t\t!languagePack ||\n\t\t\ttypeof languagePack.hash !== 'string' ||\n\t\t\t!languagePack.translations ||\n\t\t\ttypeof mainLanguagePackPath !== 'string' ||\n\t\t\t!(await exists(mainLanguagePackPath))\n\t\t) {\n\t\t\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n\t\t}\n\n\t\tconst languagePackId = `${languagePack.hash}.${resolvedLanguage}`;\n\t\tconst globalLanguagePackCachePath = path.join(userDataPath, 'clp', languagePackId);\n\t\tconst commitLanguagePackCachePath = path.join(globalLanguagePackCachePath, commit);\n\t\tconst languagePackMessagesFile = path.join(commitLanguagePackCachePath, 'nls.messages.json');\n\t\tconst translationsConfigFile = path.join(globalLanguagePackCachePath, 'tcf.json');\n\t\tconst languagePackCorruptMarkerFile = path.join(globalLanguagePackCachePath, 'corrupted.info');\n\n\t\tif (await exists(languagePackCorruptMarkerFile)) {\n\t\t\tawait fs.promises.rm(globalLanguagePackCachePath, { recursive: true, force: true, maxRetries: 3 }); // delete corrupted cache folder\n\t\t}\n\n\t\tconst result: INLSConfiguration = {\n\t\t\tuserLocale,\n\t\t\tosLocale,\n\t\t\tresolvedLanguage,\n\t\t\tdefaultMessagesFile: path.join(nlsMetadataPath, 'nls.messages.json'),\n\t\t\tlanguagePack: {\n\t\t\t\ttranslationsConfigFile,\n\t\t\t\tmessagesFile: languagePackMessagesFile,\n\t\t\t\tcorruptMarkerFile: languagePackCorruptMarkerFile\n\t\t\t},\n\n\t\t\t// NLS: below properties are a relic from old times only used by vscode-nls and deprecated\n\t\t\tlocale: userLocale,\n\t\t\tavailableLanguages: { '*': resolvedLanguage },\n\t\t\t_languagePackId: languagePackId,\n\t\t\t_languagePackSupport: true,\n\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t_cacheRoot: globalLanguagePackCachePath,\n\t\t\t_resolvedLanguagePackCoreLocation: commitLanguagePackCachePath,\n\t\t\t_corruptedFile: languagePackCorruptMarkerFile\n\t\t};\n\n\t\tif (await exists(commitLanguagePackCachePath)) {\n\t\t\ttouch(commitLanguagePackCachePath).catch(() => { }); // We don't wait for this. No big harm if we can't touch\n\t\t\tperf.mark('code/didGenerateNls');\n\t\t\treturn result;\n\t\t}\n\n\t\tconst [\n\t\t\t,\n\t\t\tnlsDefaultKeys,\n\t\t\tnlsDefaultMessages,\n\t\t\tnlsPackdata\n\t\t]:\n\t\t\t[unknown, Array<[string, string[]]>, string[], { contents: Record<string, Record<string, string>> }]\n\t\t\t//               ^moduleId ^nlsKeys                               ^moduleId      ^nlsKey ^nlsValue\n\t\t\t= await Promise.all([\n\t\t\t\tfs.promises.mkdir(commitLanguagePackCachePath, { recursive: true }),\n\t\t\t\tJSON.parse(await fs.promises.readFile(path.join(nlsMetadataPath, 'nls.keys.json'), 'utf-8')),\n\t\t\t\tJSON.parse(await fs.promises.readFile(path.join(nlsMetadataPath, 'nls.messages.json'), 'utf-8')),\n\t\t\t\tJSON.parse(await fs.promises.readFile(mainLanguagePackPath, 'utf-8'))\n\t\t\t]);\n\n\t\tconst nlsResult: string[] = [];\n\n\t\t// We expect NLS messages to be in a flat array in sorted order as they\n\t\t// where produced during build time. We use `nls.keys.json` to know the\n\t\t// right order and then lookup the related message from the translation.\n\t\t// If a translation does not exist, we fallback to the default message.\n\n\t\tlet nlsIndex = 0;\n\t\tfor (const [moduleId, nlsKeys] of nlsDefaultKeys) {\n\t\t\tconst moduleTranslations = nlsPackdata.contents[moduleId];\n\t\t\tfor (const nlsKey of nlsKeys) {\n\t\t\t\tnlsResult.push(moduleTranslations?.[nlsKey] || nlsDefaultMessages[nlsIndex]);\n\t\t\t\tnlsIndex++;\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all([\n\t\t\tfs.promises.writeFile(languagePackMessagesFile, JSON.stringify(nlsResult), 'utf-8'),\n\t\t\tfs.promises.writeFile(translationsConfigFile, JSON.stringify(languagePack.translations), 'utf-8')\n\t\t]);\n\n\t\tperf.mark('code/didGenerateNls');\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconsole.error('Generating translation files failed.', error);\n\t}\n\n\treturn defaultNLSConfiguration(userLocale, osLocale, nlsMetadataPath);\n}\n\n/**\n * The `languagepacks.json` file is a JSON file that contains all metadata\n * about installed language extensions per language. Specifically, for\n * core (`vscode`) and all extensions it supports, it points to the related\n * translation files.\n *\n * The file is updated whenever a new language pack is installed or removed.\n */\nasync function getLanguagePackConfigurations(userDataPath: string): Promise<ILanguagePacks | undefined> {\n\tconst configFile = path.join(userDataPath, 'languagepacks.json');\n\ttry {\n\t\treturn JSON.parse(await fs.promises.readFile(configFile, 'utf-8'));\n\t} catch (err) {\n\t\treturn undefined; // Do nothing. If we can't read the file we have no language pack config.\n\t}\n}\n\nfunction resolveLanguagePackLanguage(languagePacks: ILanguagePacks, locale: string | undefined): string | undefined {\n\ttry {\n\t\twhile (locale) {\n\t\t\tif (languagePacks[locale]) {\n\t\t\t\treturn locale;\n\t\t\t}\n\n\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\tif (index > 0) {\n\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('Resolving language pack configuration failed.', error);\n\t}\n\n\treturn undefined;\n}\n\nfunction defaultNLSConfiguration(userLocale: string, osLocale: string, nlsMetadataPath: string): INLSConfiguration {\n\tperf.mark('code/didGenerateNls');\n\n\treturn {\n\t\tuserLocale,\n\t\tosLocale,\n\t\tresolvedLanguage: 'en',\n\t\tdefaultMessagesFile: path.join(nlsMetadataPath, 'nls.messages.json'),\n\n\t\t// NLS: below 2 are a relic from old times only used by vscode-nls and deprecated\n\t\tlocale: userLocale,\n\t\tavailableLanguages: {}\n\t};\n}\n\n//#region fs helpers\n\nasync function exists(path: string): Promise<boolean> {\n\ttry {\n\t\tawait fs.promises.access(path);\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nfunction touch(path: string): Promise<void> {\n\tconst date = new Date();\n\n\treturn fs.promises.utimes(path, date, date);\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["path"]
}
