import{compareBy as E,groupAdjacentBy as w,numberComparator as x}from"../../../base/common/arrays.js";import{assert as N,checkAdjacentItems as R}from"../../../base/common/assert.js";import{splitLines as S}from"../../../base/common/strings.js";import{LineRange as h}from"./lineRange.js";import{OffsetEdit as T,SingleOffsetEdit as y}from"./offsetEdit.js";import{Position as c}from"./position.js";import{Range as f}from"./range.js";import{SingleTextEdit as b,TextEdit as v}from"./textEdit.js";class d{constructor(n){this.edits=n;N(R(n,(t,e)=>t.lineRange.endLineNumberExclusive<=e.lineRange.startLineNumber))}static empty=new d([]);static deserialize(n){return new d(n.map(t=>L.deserialize(t)))}static fromEdit(n,t){const e=v.fromOffsetEdit(n,t);return d.fromTextEdit(e,t)}static fromTextEdit(n,t){const e=n.edits,i=[],r=[];for(let o=0;o<e.length;o++){const u=e[o],l=o+1<e.length?e[o+1]:void 0;if(r.push(u),l&&l.range.startLineNumber===u.range.endLineNumber)continue;const s=b.joinEdits(r,t);r.length=0;const g=L.fromSingleTextEdit(s,t);i.push(g)}return new d(i)}static createFromUnsorted(n){const t=n.slice();return t.sort(E(e=>e.lineRange.startLineNumber,x)),new d(t)}toEdit(n){const t=[];for(const e of this.edits){const i=e.toSingleEdit(n);t.push(i)}return new T(t)}toString(){return this.edits.map(n=>n.toString()).join(",")}serialize(){return this.edits.map(n=>n.serialize())}getNewLineRanges(){const n=[];let t=0;for(const e of this.edits)n.push(h.ofLength(e.lineRange.startLineNumber+t,e.newLines.length)),t+=e.newLines.length-e.lineRange.length;return n}mapLineNumber(n){let t=0;for(const e of this.edits){if(e.lineRange.endLineNumberExclusive>n)break;t+=e.newLines.length-e.lineRange.length}return n+t}mapLineRange(n){return new h(this.mapLineNumber(n.startLineNumber),this.mapLineNumber(n.endLineNumberExclusive))}rebase(n){return new d(this.edits.map(t=>new L(n.mapLineRange(t.lineRange),t.newLines)))}humanReadablePatch(n){const t=[];function e(u,l,s,g){const p=s==="unmodified"?" ":s==="deleted"?"-":"+";g===void 0&&(g="[[[[[ WARNING: LINE DOES NOT EXIST ]]]]]");const a=u===-1?"   ":u.toString().padStart(3," "),m=l===-1?"   ":l.toString().padStart(3," ");t.push(`${p} ${a} ${m} ${g}`)}function i(){t.push("---")}let r=0,o=!0;for(const u of w(this.edits,(l,s)=>l.lineRange.distanceToRange(s.lineRange)<=5)){o?o=!1:i();let l=u[0].lineRange.startLineNumber-2;for(const s of u){for(let a=Math.max(1,l);a<s.lineRange.startLineNumber;a++)e(a,a+r,"unmodified",n[a-1]);const g=s.lineRange,p=s.newLines;for(const a of g.mapToLineArray(m=>m)){const m=n[a-1];e(a,-1,"deleted",m)}for(let a=0;a<p.length;a++){const m=p[a];e(-1,g.startLineNumber+r+a,"added",m)}l=g.endLineNumberExclusive,r+=s.newLines.length-s.lineRange.length}for(let s=l;s<=Math.min(l+2,n.length);s++)e(s,s+r,"unmodified",n[s-1])}return t.join(`
`)}apply(n){const t=[];let e=0;for(const i of this.edits){for(;e<i.lineRange.startLineNumber-1;)t.push(n[e]),e++;for(const r of i.newLines)t.push(r);e=i.lineRange.endLineNumberExclusive-1}for(;e<n.length;)t.push(n[e]),e++;return t}toSingleEdit(){}}class L{constructor(n,t){this.lineRange=n;this.newLines=t}static deserialize(n){return new L(h.ofLength(n[0],n[1]-n[0]),n[2])}static fromSingleTextEdit(n,t){const e=S(n.text);let i=n.range.startLineNumber;const r=t.getValueOfRange(f.fromPositions(new c(n.range.startLineNumber,1),n.range.getStartPosition()));e[0]=r+e[0];let o=n.range.endLineNumber+1;const u=t.getTransformer().getLineLength(n.range.endLineNumber)+1,l=t.getValueOfRange(f.fromPositions(n.range.getEndPosition(),new c(n.range.endLineNumber,u)));e[e.length-1]=e[e.length-1]+l;const s=n.range.startColumn===t.getTransformer().getLineLength(n.range.startLineNumber)+1,g=n.range.endColumn===1;return s&&e[0].length===r.length&&(i++,e.shift()),e.length>0&&i<o&&g&&e[e.length-1].length===l.length&&(o--,e.pop()),new L(new h(i,o),e)}toSingleTextEdit(n){if(this.newLines.length===0){const t=n.getTransformer().textLength;if(this.lineRange.endLineNumberExclusive===t.lineCount+2){let e;if(this.lineRange.startLineNumber>1){const r=this.lineRange.startLineNumber-1,o=n.getTransformer().getLineLength(r)+1;e=new c(r,o)}else e=new c(1,1);const i=t.addToPosition(new c(1,1));return new b(f.fromPositions(e,i),"")}else return new b(new f(this.lineRange.startLineNumber,1,this.lineRange.endLineNumberExclusive,1),"")}else if(this.lineRange.isEmpty){let t,e,i;const r=this.lineRange.startLineNumber;return r===n.getTransformer().textLength.lineCount+2?(t=r-1,e=n.getTransformer().getLineLength(t)+1,i=this.newLines.map(o=>`
`+o).join("")):(t=r,e=1,i=this.newLines.map(o=>o+`
`).join("")),new b(f.fromPositions(new c(t,e)),i)}else{const t=this.lineRange.endLineNumberExclusive-1,e=n.getTransformer().getLineLength(t)+1,i=new f(this.lineRange.startLineNumber,1,t,e),r=this.newLines.join(`
`);return new b(i,r)}}toSingleEdit(n){const t=this.toSingleTextEdit(n),e=n.getTransformer().getOffsetRange(t.range);return new y(e,t.text)}toString(){return`${this.lineRange}->${JSON.stringify(this.newLines)}`}serialize(){return[this.lineRange.startLineNumber,this.lineRange.endLineNumberExclusive,this.newLines]}removeCommonSuffixPrefixLines(n){let t=this.lineRange.startLineNumber,e=this.lineRange.endLineNumberExclusive,i=0;for(;t<e&&i<this.newLines.length&&this.newLines[i]===n.getLineAt(t);)t++,i++;let r=0;for(;t<e&&r+i<this.newLines.length&&this.newLines[this.newLines.length-1-r]===n.getLineAt(e-1);)e--,r++;return i===0&&r===0?this:new L(new h(t,e),this.newLines.slice(i,this.newLines.length-r))}toLineEdit(){return new d([this])}}export{d as LineEdit,L as SingleLineEdit};
