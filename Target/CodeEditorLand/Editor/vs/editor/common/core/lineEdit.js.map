{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/Land/Dependency/Editor/Source/vs/editor/common/core/lineEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, groupAdjacentBy, numberComparator } from '../../../base/common/arrays.js';\nimport { assert, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { splitLines } from '../../../base/common/strings.js';\nimport { LineRange } from './lineRange.js';\nimport { OffsetEdit, SingleOffsetEdit } from './offsetEdit.js';\nimport { Position } from './position.js';\nimport { Range } from './range.js';\nimport { AbstractText, SingleTextEdit, TextEdit } from './textEdit.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.\n *--------------------------------------------------------------------------------------------*/\n\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tpublic static deserialize(data: SerializedLineEdit): LineEdit {\n\t\treturn new LineEdit(data.map(e => SingleLineEdit.deserialize(e)));\n\t}\n\n\tpublic static fromEdit(edit: OffsetEdit, initialValue: AbstractText): LineEdit {\n\t\tconst textEdit = TextEdit.fromOffsetEdit(edit, initialValue);\n\t\treturn LineEdit.fromTextEdit(textEdit, initialValue);\n\t}\n\n\tpublic static fromTextEdit(edit: TextEdit, initialValue: AbstractText): LineEdit {\n\t\tconst edits = edit.edits;\n\n\t\tconst result: SingleLineEdit[] = [];\n\n\t\tconst currentEdits: SingleTextEdit[] = [];\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tconst nextEditRange = i + 1 < edits.length ? edits[i + 1] : undefined;\n\t\t\tcurrentEdits.push(edit);\n\t\t\tif (nextEditRange && nextEditRange.range.startLineNumber === edit.range.endLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst singleEdit = SingleTextEdit.joinEdits(currentEdits, initialValue);\n\t\t\tcurrentEdits.length = 0;\n\n\t\t\tconst singleLineEdit = SingleLineEdit.fromSingleTextEdit(singleEdit, initialValue);\n\t\t\tresult.push(singleLineEdit);\n\t\t}\n\n\t\treturn new LineEdit(result);\n\t}\n\n\tpublic static createFromUnsorted(edits: readonly SingleLineEdit[]): LineEdit {\n\t\tconst result = edits.slice();\n\t\tresult.sort(compareBy(i => i.lineRange.startLineNumber, numberComparator));\n\t\treturn new LineEdit(result);\n\t}\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly edits: readonly SingleLineEdit[]\n\t) {\n\t\tassert(checkAdjacentItems(edits, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic toEdit(initialValue: AbstractText): OffsetEdit {\n\t\tconst edits: SingleOffsetEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tconst singleEdit = edit.toSingleEdit(initialValue);\n\t\t\tedits.push(singleEdit);\n\t\t}\n\t\treturn new OffsetEdit(edits);\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.edits.map(e => e.toString()).join(',');\n\t}\n\n\tpublic serialize(): SerializedLineEdit {\n\t\treturn this.edits.map(e => e.serialize());\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic mapLineNumber(lineNumber: number): number {\n\t\tlet lineDelta = 0;\n\t\tfor (const e of this.edits) {\n\t\t\tif (e.lineRange.endLineNumberExclusive > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlineDelta += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn lineNumber + lineDelta;\n\t}\n\n\tpublic mapLineRange(lineRange: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.mapLineNumber(lineRange.startLineNumber),\n\t\t\tthis.mapLineNumber(lineRange.endLineNumberExclusive),\n\t\t);\n\t}\n\n\tpublic rebase(base: LineEdit): LineEdit {\n\t\treturn new LineEdit(\n\t\t\tthis.edits.map(e => new SingleLineEdit(base.mapLineRange(e.lineRange), e.newLines)),\n\t\t);\n\t}\n\n\tpublic humanReadablePatch(originalLines: string[]): string {\n\t\tconst result: string[] = [];\n\n\t\tfunction pushLine(originalLineNumber: number, modifiedLineNumber: number, kind: 'unmodified' | 'deleted' | 'added', content: string | undefined) {\n\t\t\tconst specialChar = (kind === 'unmodified' ? ' ' : (kind === 'deleted' ? '-' : '+'));\n\n\t\t\tif (content === undefined) {\n\t\t\t\tcontent = '[[[[[ WARNING: LINE DOES NOT EXIST ]]]]]';\n\t\t\t}\n\n\t\t\tconst origLn = originalLineNumber === -1 ? '   ' : originalLineNumber.toString().padStart(3, ' ');\n\t\t\tconst modLn = modifiedLineNumber === -1 ? '   ' : modifiedLineNumber.toString().padStart(3, ' ');\n\n\t\t\tresult.push(`${specialChar} ${origLn} ${modLn} ${content}`);\n\t\t}\n\n\t\tfunction pushSeperator() {\n\t\t\tresult.push('---');\n\t\t}\n\n\t\tlet lineDelta = 0;\n\t\tlet first = true;\n\n\t\tfor (const edits of groupAdjacentBy(this.edits, (e1, e2) => e1.lineRange.distanceToRange(e2.lineRange) <= 5)) {\n\t\t\tif (!first) {\n\t\t\t\tpushSeperator();\n\t\t\t} else {\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\tlet lastLineNumber = edits[0].lineRange.startLineNumber - 2;\n\n\t\t\tfor (const edit of edits) {\n\t\t\t\tfor (let i = Math.max(1, lastLineNumber); i < edit.lineRange.startLineNumber; i++) {\n\t\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t\t}\n\n\t\t\t\tconst range = edit.lineRange;\n\t\t\t\tconst newLines = edit.newLines;\n\t\t\t\tfor (const replaceLineNumber of range.mapToLineArray(n => n)) {\n\t\t\t\t\tconst line = originalLines[replaceLineNumber - 1];\n\t\t\t\t\tpushLine(replaceLineNumber, -1, 'deleted', line);\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < newLines.length; i++) {\n\t\t\t\t\tconst line = newLines[i];\n\t\t\t\t\tpushLine(-1, range.startLineNumber + lineDelta + i, 'added', line);\n\t\t\t\t}\n\n\t\t\t\tlastLineNumber = range.endLineNumberExclusive;\n\n\t\t\t\tlineDelta += edit.newLines.length - edit.lineRange.length;\n\t\t\t}\n\n\t\t\tfor (let i = lastLineNumber; i <= Math.min(lastLineNumber + 2, originalLines.length); i++) {\n\t\t\t\tpushLine(i, i + lineDelta, 'unmodified', originalLines[i - 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tpublic apply(lines: string[]): string[] {\n\t\tconst result: string[] = [];\n\n\t\tlet currentLineIndex = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\twhile (currentLineIndex < edit.lineRange.startLineNumber - 1) {\n\t\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\t\tcurrentLineIndex++;\n\t\t\t}\n\n\t\t\tfor (const newLine of edit.newLines) {\n\t\t\t\tresult.push(newLine);\n\t\t\t}\n\n\t\t\tcurrentLineIndex = edit.lineRange.endLineNumberExclusive - 1;\n\t\t}\n\n\t\twhile (currentLineIndex < lines.length) {\n\t\t\tresult.push(lines[currentLineIndex]);\n\t\t\tcurrentLineIndex++;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic toSingleEdit() {\n\n\t}\n}\n\nexport class SingleLineEdit {\n\tpublic static deserialize(e: SerializedSingleLineEdit): SingleLineEdit {\n\t\treturn new SingleLineEdit(\n\t\t\tLineRange.ofLength(e[0], e[1] - e[0]),\n\t\t\te[2],\n\t\t);\n\t}\n\n\tpublic static fromSingleTextEdit(edit: SingleTextEdit, initialValue: AbstractText): SingleLineEdit {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new SingleLineEdit(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toSingleTextEdit(initialValue: AbstractText): SingleTextEdit {\n\t\tif (this.newLines.length === 0) {\n\t\t\t// Deletion\n\t\t\tconst textLen = initialValue.getTransformer().textLength;\n\t\t\tif (this.lineRange.endLineNumberExclusive === textLen.lineCount + 2) {\n\t\t\t\tlet startPos: Position;\n\t\t\t\tif (this.lineRange.startLineNumber > 1) {\n\t\t\t\t\tconst startLineNumber = this.lineRange.startLineNumber - 1;\n\t\t\t\t\tconst startColumn = initialValue.getTransformer().getLineLength(startLineNumber) + 1;\n\t\t\t\t\tstartPos = new Position(startLineNumber, startColumn);\n\t\t\t\t} else {\n\t\t\t\t\t// Delete everything.\n\t\t\t\t\t// In terms of lines, this would end up with 0 lines.\n\t\t\t\t\t// However, a string has always 1 line (which can be empty).\n\t\t\t\t\tstartPos = new Position(1, 1);\n\t\t\t\t}\n\n\t\t\t\tconst lastPosition = textLen.addToPosition(new Position(1, 1));\n\t\t\t\treturn new SingleTextEdit(Range.fromPositions(startPos, lastPosition), '');\n\t\t\t} else {\n\t\t\t\treturn new SingleTextEdit(new Range(this.lineRange.startLineNumber, 1, this.lineRange.endLineNumberExclusive, 1), '');\n\t\t\t}\n\n\t\t} else if (this.lineRange.isEmpty) {\n\t\t\t// Insertion\n\n\t\t\tlet endLineNumber: number;\n\t\t\tlet column: number;\n\t\t\tlet text: string;\n\t\t\tconst insertionLine = this.lineRange.startLineNumber;\n\t\t\tif (insertionLine === initialValue.getTransformer().textLength.lineCount + 2) {\n\t\t\t\tendLineNumber = insertionLine - 1;\n\t\t\t\tcolumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\t\ttext = this.newLines.map(l => '\\n' + l).join('');\n\t\t\t} else {\n\t\t\t\tendLineNumber = insertionLine;\n\t\t\t\tcolumn = 1;\n\t\t\t\ttext = this.newLines.map(l => l + '\\n').join('');\n\t\t\t}\n\t\t\treturn new SingleTextEdit(Range.fromPositions(new Position(endLineNumber, column)), text);\n\t\t} else {\n\t\t\tconst endLineNumber = this.lineRange.endLineNumberExclusive - 1;\n\t\t\tconst endLineNumberMaxColumn = initialValue.getTransformer().getLineLength(endLineNumber) + 1;\n\t\t\tconst range = new Range(\n\t\t\t\tthis.lineRange.startLineNumber,\n\t\t\t\t1,\n\t\t\t\tendLineNumber,\n\t\t\t\tendLineNumberMaxColumn\n\t\t\t);\n\t\t\t// Don't add \\n to the last line. This is because we subtract one from lineRange.endLineNumberExclusive for endLineNumber.\n\t\t\tconst text = this.newLines.join('\\n');\n\t\t\treturn new SingleTextEdit(range, text);\n\t\t}\n\t}\n\n\tpublic toSingleEdit(initialValue: AbstractText): SingleOffsetEdit {\n\t\tconst textEdit = this.toSingleTextEdit(initialValue);\n\t\tconst range = initialValue.getTransformer().getOffsetRange(textEdit.range);\n\t\treturn new SingleOffsetEdit(range, textEdit.text);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic serialize(): SerializedSingleLineEdit {\n\t\treturn [\n\t\t\tthis.lineRange.startLineNumber,\n\t\t\tthis.lineRange.endLineNumberExclusive,\n\t\t\tthis.newLines,\n\t\t];\n\t}\n\n\tpublic removeCommonSuffixPrefixLines(initialValue: AbstractText): SingleLineEdit {\n\t\tlet startLineNumber = this.lineRange.startLineNumber;\n\t\tlet endLineNumberEx = this.lineRange.endLineNumberExclusive;\n\n\t\tlet trimStartCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[trimStartCount] === initialValue.getLineAt(startLineNumber)\n\t\t) {\n\t\t\tstartLineNumber++;\n\t\t\ttrimStartCount++;\n\t\t}\n\n\t\tlet trimEndCount = 0;\n\t\twhile (\n\t\t\tstartLineNumber < endLineNumberEx && trimEndCount + trimStartCount < this.newLines.length\n\t\t\t&& this.newLines[this.newLines.length - 1 - trimEndCount] === initialValue.getLineAt(endLineNumberEx - 1)\n\t\t) {\n\t\t\tendLineNumberEx--;\n\t\t\ttrimEndCount++;\n\t\t}\n\n\t\tif (trimStartCount === 0 && trimEndCount === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SingleLineEdit(new LineRange(startLineNumber, endLineNumberEx), this.newLines.slice(trimStartCount, this.newLines.length - trimEndCount));\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n\nexport type SerializedLineEdit = SerializedSingleLineEdit[];\nexport type SerializedSingleLineEdit = [startLineNumber: number, endLineNumber: number, newLines: readonly string[]];\n"],
  "mappings": "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",
  "names": ["edit"]
}
