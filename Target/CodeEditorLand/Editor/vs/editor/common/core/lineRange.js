import{BugIndicatingError as b}from"../../../base/common/errors.js";import{OffsetRange as N}from"./offsetRange.js";import{Range as L}from"./range.js";import{findFirstIdxMonotonousOrArrLen as c,findLastIdxMonotonous as o,findLastMonotonous as d}from"../../../base/common/arraysFind.js";class s{static fromRange(e){return new s(e.startLineNumber,e.endLineNumber)}static fromRangeInclusive(e){return new s(e.startLineNumber,e.endLineNumber+1)}static subtract(e,n){return n?e.startLineNumber<n.startLineNumber&&n.endLineNumberExclusive<e.endLineNumberExclusive?[new s(e.startLineNumber,n.startLineNumber),new s(n.endLineNumberExclusive,e.endLineNumberExclusive)]:n.startLineNumber<=e.startLineNumber&&e.endLineNumberExclusive<=n.endLineNumberExclusive?[]:n.endLineNumberExclusive<e.endLineNumberExclusive?[new s(Math.max(n.endLineNumberExclusive,e.startLineNumber),e.endLineNumberExclusive)]:[new s(e.startLineNumber,Math.min(n.startLineNumber,e.endLineNumberExclusive))]:[e]}static joinMany(e){if(e.length===0)return[];let n=new l(e[0].slice());for(let i=1;i<e.length;i++)n=n.getUnion(new l(e[i].slice()));return n.ranges}static join(e){if(e.length===0)throw new b("lineRanges cannot be empty");let n=e[0].startLineNumber,i=e[0].endLineNumberExclusive;for(let t=1;t<e.length;t++)n=Math.min(n,e[t].startLineNumber),i=Math.max(i,e[t].endLineNumberExclusive);return new s(n,i)}static ofLength(e,n){return new s(e,e+n)}static deserialize(e){return new s(e[0],e[1])}startLineNumber;endLineNumberExclusive;constructor(e,n){if(e>n)throw new b(`startLineNumber ${e} cannot be after endLineNumberExclusive ${n}`);this.startLineNumber=e,this.endLineNumberExclusive=n}contains(e){return this.startLineNumber<=e&&e<this.endLineNumberExclusive}get isEmpty(){return this.startLineNumber===this.endLineNumberExclusive}delta(e){return new s(this.startLineNumber+e,this.endLineNumberExclusive+e)}deltaLength(e){return new s(this.startLineNumber,this.endLineNumberExclusive+e)}get length(){return this.endLineNumberExclusive-this.startLineNumber}join(e){return new s(Math.min(this.startLineNumber,e.startLineNumber),Math.max(this.endLineNumberExclusive,e.endLineNumberExclusive))}toString(){return`[${this.startLineNumber},${this.endLineNumberExclusive})`}intersect(e){const n=Math.max(this.startLineNumber,e.startLineNumber),i=Math.min(this.endLineNumberExclusive,e.endLineNumberExclusive);if(n<=i)return new s(n,i)}intersectsStrict(e){return this.startLineNumber<e.endLineNumberExclusive&&e.startLineNumber<this.endLineNumberExclusive}overlapOrTouch(e){return this.startLineNumber<=e.endLineNumberExclusive&&e.startLineNumber<=this.endLineNumberExclusive}equals(e){return this.startLineNumber===e.startLineNumber&&this.endLineNumberExclusive===e.endLineNumberExclusive}toInclusiveRange(){return this.isEmpty?null:new L(this.startLineNumber,1,this.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER)}toExclusiveRange(){return new L(this.startLineNumber,1,this.endLineNumberExclusive,1)}mapToLineArray(e){const n=[];for(let i=this.startLineNumber;i<this.endLineNumberExclusive;i++)n.push(e(i));return n}forEach(e){for(let n=this.startLineNumber;n<this.endLineNumberExclusive;n++)e(n)}serialize(){return[this.startLineNumber,this.endLineNumberExclusive]}includes(e){return this.startLineNumber<=e&&e<this.endLineNumberExclusive}toOffsetRange(){return new N(this.startLineNumber-1,this.endLineNumberExclusive-1)}distanceToRange(e){return this.endLineNumberExclusive<=e.startLineNumber?e.startLineNumber-this.endLineNumberExclusive:e.endLineNumberExclusive<=this.startLineNumber?this.startLineNumber-e.endLineNumberExclusive:0}distanceToLine(e){return this.contains(e)?0:e<this.startLineNumber?this.startLineNumber-e:e-this.endLineNumberExclusive}}class l{constructor(e=[]){this._normalizedRanges=e}get ranges(){return this._normalizedRanges}addRange(e){if(e.length===0)return;const n=c(this._normalizedRanges,t=>t.endLineNumberExclusive>=e.startLineNumber),i=o(this._normalizedRanges,t=>t.startLineNumber<=e.endLineNumberExclusive)+1;if(n===i)this._normalizedRanges.splice(n,0,e);else if(n===i-1){const t=this._normalizedRanges[n];this._normalizedRanges[n]=t.join(e)}else{const t=this._normalizedRanges[n].join(this._normalizedRanges[i-1]).join(e);this._normalizedRanges.splice(n,i-n,t)}}contains(e){const n=d(this._normalizedRanges,i=>i.startLineNumber<=e);return!!n&&n.endLineNumberExclusive>e}intersects(e){const n=d(this._normalizedRanges,i=>i.startLineNumber<e.endLineNumberExclusive);return!!n&&n.endLineNumberExclusive>e.startLineNumber}getUnion(e){if(this._normalizedRanges.length===0)return e;if(e._normalizedRanges.length===0)return this;const n=[];let i=0,t=0,r=null;for(;i<this._normalizedRanges.length||t<e._normalizedRanges.length;){let u=null;if(i<this._normalizedRanges.length&&t<e._normalizedRanges.length){const a=this._normalizedRanges[i],m=e._normalizedRanges[t];a.startLineNumber<m.startLineNumber?(u=a,i++):(u=m,t++)}else i<this._normalizedRanges.length?(u=this._normalizedRanges[i],i++):(u=e._normalizedRanges[t],t++);r===null?r=u:r.endLineNumberExclusive>=u.startLineNumber?r=new s(r.startLineNumber,Math.max(r.endLineNumberExclusive,u.endLineNumberExclusive)):(n.push(r),r=u)}return r!==null&&n.push(r),new l(n)}subtractFrom(e){const n=c(this._normalizedRanges,u=>u.endLineNumberExclusive>=e.startLineNumber),i=o(this._normalizedRanges,u=>u.startLineNumber<=e.endLineNumberExclusive)+1;if(n===i)return new l([e]);const t=[];let r=e.startLineNumber;for(let u=n;u<i;u++){const a=this._normalizedRanges[u];a.startLineNumber>r&&t.push(new s(r,a.startLineNumber)),r=a.endLineNumberExclusive}return r<e.endLineNumberExclusive&&t.push(new s(r,e.endLineNumberExclusive)),new l(t)}toString(){return this._normalizedRanges.map(e=>e.toString()).join(", ")}getIntersection(e){const n=[];let i=0,t=0;for(;i<this._normalizedRanges.length&&t<e._normalizedRanges.length;){const r=this._normalizedRanges[i],u=e._normalizedRanges[t],a=r.intersect(u);a&&!a.isEmpty&&n.push(a),r.endLineNumberExclusive<u.endLineNumberExclusive?i++:t++}return new l(n)}getWithDelta(e){return new l(this._normalizedRanges.map(n=>n.delta(e)))}}export{s as LineRange,l as LineRangeSet};
