{
  "version": 3,
  "sources": ["../../../../../../../../../Dependency/Land/Dependency/Editor/Source/vs/editor/common/core/textEdit.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert, assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../base/common/strings.js';\nimport { ISingleEditOperation } from './editOperation.js';\nimport { LineRange } from './lineRange.js';\nimport { OffsetEdit } from './offsetEdit.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\n\nexport class TextEdit {\n\tpublic static fromOffsetEdit(edit: OffsetEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.edits.map(e => new SingleTextEdit(initialState.getTransformer().getRange(e.replaceRange), e.newText));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static single(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(originalRange, newText)]);\n\t}\n\n\tpublic static insert(position: Position, newText: string): TextEdit {\n\t\treturn new TextEdit([new SingleTextEdit(Range.fromPositions(position, position), newText)]);\n\t}\n\n\tconstructor(public readonly edits: readonly SingleTextEdit[]) {\n\t\tassertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst edits: SingleTextEdit[] = [];\n\t\tfor (const edit of this.edits) {\n\t\t\tif (edits.length > 0 && edits[edits.length - 1].range.getEndPosition().equals(edit.range.getStartPosition())) {\n\t\t\t\tconst last = edits[edits.length - 1];\n\t\t\t\tedits[edits.length - 1] = new SingleTextEdit(last.range.plusRange(edit.range), last.text + edit.text);\n\t\t\t} else if (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(edits);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const edit of this.edits) {\n\t\t\tconst start = edit.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = edit.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(edit.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (edit.range.endLineNumber - edit.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const edit of this.edits) {\n\t\t\tconst editRange = edit.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += edit.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.edits.map((e, idx) => new SingleTextEdit(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const edit of this.edits) {\n\t\t\tconst textLength = TextLength.ofText(edit.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - edit.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoSingle(text: AbstractText) {\n\t\tif (this.edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.edits.length === 1) { return this.edits[0]; }\n\n\t\tconst startPos = this.edits[0].range.getStartPosition();\n\t\tconst endPos = this.edits[this.edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.edits.length; i++) {\n\t\t\tconst curEdit = this.edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.edits.length - 1) {\n\t\t\t\tconst nextEdit = this.edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n}\n\nexport class SingleTextEdit {\n\tpublic static joinEdits(edits: SingleTextEdit[], initialValue: AbstractText): SingleTextEdit {\n\t\tif (edits.length === 0) { throw new BugIndicatingError(); }\n\t\tif (edits.length === 1) { return edits[0]; }\n\n\t\tconst startPos = edits[0].range.getStartPosition();\n\t\tconst endPos = edits[edits.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst curEdit = edits[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < edits.length - 1) {\n\t\t\t\tconst nextEdit = edits[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new SingleTextEdit(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n\n\tpublic toEdit(): TextEdit {\n\t\treturn new TextEdit([this]);\n\t}\n\n\tpublic equals(other: SingleTextEdit): boolean {\n\t\treturn SingleTextEdit.equals(this, other);\n\t}\n\n\tpublic extendToCoverRange(range: Range, initialValue: AbstractText): SingleTextEdit {\n\t\tif (this.range.containsRange(range)) { return this; }\n\n\t\tconst newRange = this.range.plusRange(range);\n\t\tconst textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));\n\t\tconst textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));\n\t\tconst newText = textBefore + this.text + textAfter;\n\t\treturn new SingleTextEdit(newRange, newText);\n\t}\n\n\tpublic extendToFullLine(initialValue: AbstractText): SingleTextEdit {\n\t\tconst newRange = new Range(\n\t\t\tthis.range.startLineNumber,\n\t\t\t1,\n\t\t\tthis.range.endLineNumber,\n\t\t\tinitialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1\n\t\t);\n\t\treturn this.extendToCoverRange(newRange, initialValue);\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): SingleTextEdit {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, newText);\n\t}\n\n\tpublic isEffectiveDeletion(text: AbstractText): boolean {\n\t\tlet newText = this.text.replaceAll('\\r\\n', '\\n');\n\t\tlet existingText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst l = commonPrefixLength(newText, existingText);\n\t\tnewText = newText.substring(l);\n\t\texistingText = existingText.substring(l);\n\t\tconst r = commonSuffixLength(newText, existingText);\n\t\tnewText = newText.substring(0, newText.length - r);\n\t\texistingText = existingText.substring(0, existingText.length - r);\n\n\t\treturn newText === '';\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number,\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t = new PositionOffsetTransformer(this.value);\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["r"]
}
