import{h as m}from"../../../../../../base/browser/dom.js";import{KeybindingLabel as u,unthemedKeybindingLabelOptions as c}from"../../../../../../base/browser/ui/keybindingLabel/keybindingLabel.js";import"../../../../../../base/common/observable.js";import{OS as b}from"../../../../../../base/common/platform.js";import{URI as g}from"../../../../../../base/common/uri.js";import{MenuEntryActionViewItem as f}from"../../../../../../platform/actions/browser/menuEntryActionViewItem.js";import"../../../../../browser/observableCodeEditor.js";import"../../../../../common/core/lineRange.js";import"../../../../../common/core/textEdit.js";import{RangeMapping as h}from"../../../../../common/diff/rangeMapping.js";function K(i,e,t){i.layoutInfo.read(t),i.value.read(t);const n=i.model.read(t);if(!n)return 0;let r=0;i.scrollTop.read(t);for(let o=e.startLineNumber;o<e.endLineNumberExclusive;o++){const d=n.getLineMaxColumn(o),p=i.editor.getOffsetForColumn(o,d);r=Math.max(r,p)}const l=e.mapToLineArray(o=>n.getLineContent(o));return r<5&&l.some(o=>o.length>0)&&n.uri.scheme,r}class U extends f{updateLabel(){const e=this._keybindingService.lookupKeybinding(this._action.id,this._contextKeyService);if(!e)return super.updateLabel();if(this.label){const t=m("div.keybinding").root;this._register(new u(t,b,{disableTitle:!0,...c})).set(e),this.label.textContent=this._action.label,this.label.appendChild(t),this.label.classList.add("inlineSuggestionStatusBarItemLabel")}}updateTooltip(){}}class a{constructor(e,t){this.x=e;this.y=t}add(e){return new a(this.x+e.x,this.y+e.y)}deltaX(e){return new a(this.x+e,this.y)}}class s{constructor(e){this.scheme=e}static _modelId=0;getUniqueUri(){return g.from({scheme:this.scheme,path:new Date().toString()+String(s._modelId++)})}}function _(i,e){const t=[];for(const n of i){const r=e.mapRange(n.modifiedRange);t.push(new h(n.originalRange,r))}return t}export{a as Point,U as StatusBarViewItem,s as UniqueUriGenerator,_ as applyEditToModifiedRangeMappings,K as maxLeftInRange};
