var z=Object.defineProperty;var J=Object.getOwnPropertyDescriptor;var V=(a,c,t,e)=>{for(var n=e>1?void 0:e?J(c,t):c,o=a.length-1,r;o>=0;o--)(r=a[o])&&(n=(e?r(c,t,n):r(n))||n);return e&&n&&z(c,t,n),n},b=(a,c)=>(t,e)=>c(t,e,a);import*as X from"../../../nls.js";import{URI as E}from"../../../base/common/uri.js";import{generateUuid as Y}from"../../../base/common/uuid.js";import*as T from"../../../base/common/types.js";import*as g from"../../../base/common/platform.js";import"../../../base/common/collections.js";import{Disposable as Z}from"../../../base/common/lifecycle.js";import{IWorkspaceContextService as ee}from"../../../platform/workspace/common/workspace.js";import{ContributedTask as y,ConfiguringTask as w,TaskEventKind as O,CommandOptions as v,RuntimeType as x,CustomTask as ne,TaskScope as h,TaskSourceKind as W,TaskDefinition as oe,PresentationOptions as N,RunOptions as K}from"../../contrib/tasks/common/tasks.js";import"../../contrib/tasks/common/taskSystem.js";import{ITaskService as te}from"../../contrib/tasks/common/taskService.js";import{extHostNamedCustomer as re}from"../../services/extensions/common/extHostCustomers.js";import{ExtHostContext as ie,MainContext as se}from"../common/extHost.protocol.js";import"../common/shared/tasks.js";import{IConfigurationResolverService as ce}from"../../services/configurationResolver/common/configurationResolver.js";import"../../../platform/configuration/common/configuration.js";import{ErrorNoTelemetry as ae}from"../../../base/common/errors.js";import"../../../platform/extensions/common/extensions.js";var $;(c=>{function a(t){return{id:t.id,task:u.from(t.task)}}c.from=a})($||={});var U;(c=>{function a(t,e){return{id:t.id,processId:e}}c.from=a})(U||={});var B;(c=>{function a(t,e){return{id:t.id,exitCode:e}}c.from=a})(B||={});var F;(t=>{function a(e){const n=Object.assign(Object.create(null),e);return delete n._key,n}t.from=a;function c(e,n){let o=oe.createTaskIdentifier(e,console);return o===void 0&&n&&(o={_key:Y(),type:"$executeOnly"}),o}t.to=c})(F||={});var R;(t=>{function a(e){if(e!=null)return Object.assign(Object.create(null),e)}t.from=a;function c(e){return e==null?N.defaults:Object.assign(Object.create(null),N.defaults,e)}t.to=c})(R||={});var H;(t=>{function a(e){if(e!=null)return Object.assign(Object.create(null),e)}t.from=a;function c(e){return e==null?K.defaults:Object.assign(Object.create(null),K.defaults,e)}t.to=c})(H||={});var M;(t=>{function a(e){if(e!=null)return{cwd:e.cwd,env:e.env}}t.from=a;function c(e){return e==null?v.defaults:{cwd:e.cwd||v.defaults.cwd,env:e.env}}t.to=c})(M||={});var S;(e=>{function a(n){const o=n;return o&&!!o.process}e.is=a;function c(n){const o=T.isString(n.name)?n.name:n.name.value,r=n.args?n.args.map(i=>T.isString(i)?i:i.value):[],s={process:o,args:r};return n.options&&(s.options=M.from(n.options)),s}e.from=c;function t(n){const o={runtime:x.Process,name:n.process,args:n.args,presentation:void 0};return o.options=M.to(n.options),o}e.to=t})(S||={});var j;(t=>{function a(e){if(e==null)return;const n={cwd:e.cwd||v.defaults.cwd,env:e.env};return e.shell&&(n.executable=e.shell.executable,n.shellArgs=e.shell.args,n.shellQuoting=e.shell.quoting),n}t.from=a;function c(e){if(e==null)return;const n={cwd:e.cwd,env:e.env};return e.executable&&(n.shell={executable:e.executable},e.shellArgs&&(n.shell.args=e.shellArgs),e.shellQuoting&&(n.shell.quoting=e.shellQuoting)),n}t.to=c})(j||={});var C;(e=>{function a(n){const o=n;return o&&(!!o.commandLine||!!o.command)}e.is=a;function c(n){const o={};return n.name&&T.isString(n.name)&&(n.args===void 0||n.args===null||n.args.length===0)?o.commandLine=n.name:(o.command=n.name,o.args=n.args),n.options&&(o.options=j.from(n.options)),o}e.from=c;function t(n){const o={runtime:x.Shell,name:n.commandLine?n.commandLine:n.command,args:n.args,presentation:void 0};return n.options&&(o.options=j.to(n.options)),o}e.to=t})(C||={});var k;(e=>{function a(n){const o=n;return o&&o.customExecution==="customExecution"}e.is=a;function c(n){return{customExecution:"customExecution"}}e.from=c;function t(n){return{runtime:x.CustomExecution,presentation:void 0}}e.to=t})(k||={});var A;(t=>{function a(e){const n={label:e.label};return e.kind===W.Extension?(n.extensionId=e.extension,e.workspaceFolder?n.scope=e.workspaceFolder.uri:n.scope=e.scope):e.kind===W.Workspace&&(n.extensionId="$core",n.scope=e.config.workspaceFolder?e.config.workspaceFolder.uri:h.Global),n}t.from=a;function c(e,n){let o,r;return e.scope===void 0||typeof e.scope=="number"&&e.scope!==h.Global?n.getWorkspace().folders.length===0?(o=h.Global,r=void 0):(o=h.Folder,r=n.getWorkspace().folders[0]):typeof e.scope=="number"?o=e.scope:(o=h.Folder,r=n.getWorkspaceFolder(E.revive(e.scope))??void 0),{kind:W.Extension,label:e.label,extension:e.extensionId,scope:o,workspaceFolder:r}}t.to=c})(A||={});var G;(c=>{function a(t){const e=t;return e&&T.isString(e.id)&&!!e.workspaceFolder}c.is=a})(G||={});var u;(t=>{function a(e){if(e==null||!ne.is(e)&&!y.is(e)&&!w.is(e))return;const n={_id:e._id,name:e.configurationProperties.name,definition:F.from(e.getDefinition(!0)),source:A.from(e._source),execution:void 0,presentationOptions:!w.is(e)&&e.command?R.from(e.command.presentation):void 0,isBackground:e.configurationProperties.isBackground,problemMatchers:[],hasDefinedMatchers:y.is(e)?e.hasDefinedMatchers:!1,runOptions:H.from(e.runOptions)};if(n.group=Q.from(e.configurationProperties.group),e.configurationProperties.detail&&(n.detail=e.configurationProperties.detail),!w.is(e)&&e.command)switch(e.command.runtime){case x.Process:n.execution=S.from(e.command);break;case x.Shell:n.execution=C.from(e.command);break;case x.CustomExecution:n.execution=k.from(e.command);break}if(e.configurationProperties.problemMatchers)for(const o of e.configurationProperties.problemMatchers)T.isString(o)&&n.problemMatchers.push(o);return n}t.from=a;function c(e,n,o,r,s){if(!e||typeof e.name!="string")return;let i;if(e.execution&&(C.is(e.execution)?i=C.to(e.execution):S.is(e.execution)?i=S.to(e.execution):k.is(e.execution)&&(i=k.to(e.execution))),!i)return;i.presentation=R.to(e.presentationOptions);const d=A.to(e.source,n),f=X.localize("task.label","{0}: {1}",d.label,e.name),p=F.to(e.definition,o),I=k.is(e.execution)&&e._id?e._id:`${e.source.extensionId}.${p._key}`;return new y(I,d,f,p.type,p,i,e.hasDefinedMatchers,H.to(e.runOptions),{name:e.name,identifier:f,group:e.group,isBackground:!!e.isBackground,problemMatchers:e.problemMatchers.slice(),detail:e.detail,icon:r,hide:s})}t.to=c})(u||={});var Q;(c=>{function a(t){if(t!==void 0)return{_id:typeof t=="string"?t:t._id,isDefault:typeof t=="string"||typeof t.isDefault=="string"?!1:t.isDefault}}c.from=a})(Q||={});var q;(t=>{function a(e){return e}t.from=a;function c(e){return e}t.to=c})(q||={});let P=class extends Z{constructor(t,e,n,o){super();this._taskService=e;this._workspaceContextServer=n;this._configurationResolverService=o;this._proxy=t.getProxy(ie.ExtHostTask),this._providers=new Map,this._register(this._taskService.onDidStateChange(async r=>{if(r.kind===O.Changed)return;const s=r.__task;if(r.kind===O.Start){const i=$.from(s.getTaskExecution());let d=i.task.definition;if(i.task?.execution&&k.is(i.task.execution)&&r.resolvedVariables){const f={};for(const[p,I]of r.resolvedVariables.entries())f[p]=I;d=await this._configurationResolverService.resolveAnyAsync(s.getWorkspaceFolder(),i.task.definition,f)}this._proxy.$onDidStartTask(i,r.terminalId,d)}else r.kind===O.ProcessStarted?this._proxy.$onDidStartTaskProcess(U.from(s.getTaskExecution(),r.processId)):r.kind===O.ProcessEnded?this._proxy.$onDidEndTaskProcess(B.from(s.getTaskExecution(),r.exitCode)):r.kind===O.End&&this._proxy.$OnDidEndTask($.from(s.getTaskExecution()))}))}_extHostContext;_proxy;_providers;dispose(){for(const t of this._providers.values())t.disposable.dispose();this._providers.clear(),super.dispose()}$createTaskId(t){return new Promise((e,n)=>{const o=u.to(t,this._workspaceContextServer,!0);o?e(o._id):n(new Error("Task could not be created from DTO"))})}$registerTaskProvider(t,e){const n={provideTasks:r=>Promise.resolve(this._proxy.$provideTasks(t,r)).then(s=>{const i=[];for(const f of s.tasks){const p=u.to(f,this._workspaceContextServer,!0);p&&i.push(p)}const d={...s.extension,extensionLocation:E.revive(s.extension.extensionLocation)};return{tasks:i,extension:d}}),resolveTask:r=>{const s=u.from(r);return s?(s.name=s.name===void 0?"":s.name,Promise.resolve(this._proxy.$resolveTask(t,s)).then(i=>{if(i)return u.to(i,this._workspaceContextServer,!0,r.configurationProperties.icon,r.configurationProperties.hide)})):Promise.resolve(void 0)}},o=this._taskService.registerTaskProvider(n,e);return this._providers.set(t,{disposable:o,provider:n}),Promise.resolve(void 0)}$unregisterTaskProvider(t){const e=this._providers.get(t);return e&&(e.disposable.dispose(),this._providers.delete(t)),Promise.resolve(void 0)}$fetchTasks(t){return this._taskService.tasks(q.to(t)).then(e=>{const n=[];for(const o of e){const r=u.from(o);r&&n.push(r)}return n})}getWorkspace(t){let e;if(typeof t=="string")e=t;else{const n=this._workspaceContextServer.getWorkspace(),o=E.revive(t);n.configuration?.toString()===o.toString()?e=n:e=this._workspaceContextServer.getWorkspaceFolder(o)}return e}async $getTaskExecution(t){if(G.is(t)){const e=this.getWorkspace(t.workspaceFolder);if(e){const n=await this._taskService.getTask(e,t.id,!0);if(n)return{id:n._id,task:u.from(n)};throw new Error("Task not found")}else throw new Error("No workspace folder")}else{const e=u.to(t,this._workspaceContextServer,!0);return{id:e._id,task:u.from(e)}}}$executeTask(t){return new Promise((e,n)=>{if(G.is(t)){const o=this.getWorkspace(t.workspaceFolder);o?this._taskService.getTask(o,t.id,!0).then(r=>{if(!r)n(new Error("Task not found"));else{const s={id:t.id,task:u.from(r)};this._taskService.run(r).then(i=>{(i?.exitCode===void 0||i.exitCode!==0)&&this._proxy.$OnDidEndTask(s)},i=>{}),e(s)}},r=>{n(new Error("Task not found"))}):n(new Error("No workspace folder"))}else{const o=u.to(t,this._workspaceContextServer,!0);this._taskService.run(o).then(void 0,s=>{});const r={id:o._id,task:u.from(o)};e(r)}})}$customExecutionComplete(t,e){return new Promise((n,o)=>{this._taskService.getActiveTasks().then(r=>{for(const s of r)if(t===s._id){this._taskService.extensionCallbackTaskComplete(s,e).then(i=>{n(void 0)},i=>{o(i)});return}o(new Error("Task to mark as complete not found"))})})}$terminateTask(t){return new Promise((e,n)=>{this._taskService.getActiveTasks().then(o=>{for(const r of o)if(t===r._id){this._taskService.terminate(r).then(s=>{e(void 0)},s=>{n(void 0)});return}n(new ae("Task to terminate not found"))})})}$registerTaskSystem(t,e){let n;switch(e.platform){case"Web":n=g.Platform.Web;break;case"win32":n=g.Platform.Windows;break;case"darwin":n=g.Platform.Mac;break;case"linux":n=g.Platform.Linux;break;default:n=g.platform}this._taskService.registerTaskSystem(t,{platform:n,uriProvider:o=>E.from({scheme:e.scheme,authority:e.authority,path:o}),context:this._extHostContext,resolveVariables:(o,r,s)=>{const i=[];return r.variables.forEach(d=>i.push(d)),Promise.resolve(this._proxy.$resolveVariables(o.uri,{process:r.process,variables:i})).then(d=>{const f=Array.from(Object.values(d.variables));return new Promise((p,I)=>{this._configurationResolverService.resolveWithInteraction(o,f,"tasks",void 0,s).then(l=>{l||p(void 0);const D={process:void 0,variables:new Map};for(let m=0;m<f.length;m++){const _=i[m].substring(2,i[m].length-1);if(l&&d.variables[i[m]]===i[m]){const L=l.get(_);typeof L=="string"&&D.variables.set(_,L)}else D.variables.set(_,f[m])}T.isString(d.process)&&(D.process=d.process),p(D)},l=>{I(l)})})})},findExecutable:(o,r,s)=>this._proxy.$findExecutable(o,r,s)})}async $registerSupportedExecutions(t,e,n){return this._taskService.registerSupportedExecutions(t,e,n)}};P=V([re(se.MainThreadTask),b(1,te),b(2,ee),b(3,ce)],P);export{P as MainThreadTask};
