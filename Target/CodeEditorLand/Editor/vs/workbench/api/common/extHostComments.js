var w=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var I=(y,T,b,d)=>{for(var c=d>1?void 0:d?V(T,b):T,p=y.length-1,_;p>=0;p--)(_=y[p])&&(c=(d?_(T,b,c):_(c))||c);return d&&c&&w(T,b,c),c};import{asPromise as D}from"../../../base/common/async.js";import"../../../base/common/cancellation.js";import{debounce as O}from"../../../base/common/decorators.js";import{Emitter as B}from"../../../base/common/event.js";import{DisposableStore as P,MutableDisposable as j}from"../../../base/common/lifecycle.js";import{MarshalledId as v}from"../../../base/common/marshallingIds.js";import{URI as x}from"../../../base/common/uri.js";import"../../../editor/common/core/range.js";import*as h from"../../../editor/common/languages.js";import{ExtensionIdentifierMap as F}from"../../../platform/extensions/common/extensions.js";import"./extHostDocuments.js";import*as g from"./extHostTypeConverters.js";import*as u from"./extHostTypes.js";import{MainContext as k}from"./extHost.protocol.js";import"./extHostCommands.js";import{checkProposedApiEnabled as C}from"../../services/extensions/common/extensions.js";import"../../common/comments.js";function Ce(y,T,b){const d=y.getProxy(k.MainThreadComments);class c{static handlePool=0;_commentControllers=new Map;_commentControllersByExtension=new F;constructor(){T.registerArgumentProcessor({processArgument:e=>{if(e&&e.$mid===v.CommentController){const t=this._commentControllers.get(e.handle);return t?t.value:e}else if(e&&e.$mid===v.CommentThread){const t=e,n=this._commentControllers.get(t.commentControlHandle);if(!n)return t;const o=n.getCommentThread(t.commentThreadHandle);return o?o.value:t}else if(e&&(e.$mid===v.CommentThreadReply||e.$mid===v.CommentThreadInstance)){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);return n?e.$mid===v.CommentThreadInstance?n.value:{thread:n.value,text:e.text}:e}else if(e&&e.$mid===v.CommentNode){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);if(!n)return e;const o=e.commentUniqueId,i=n.getCommentByUniqueId(o);return i||e}else if(e&&e.$mid===v.CommentThreadNode){const t=this._commentControllers.get(e.thread.commentControlHandle);if(!t)return e;const n=t.getCommentThread(e.thread.commentThreadHandle);if(!n)return e;const o=e.text,i=e.commentUniqueId,a=n.getCommentByUniqueId(i);return a?(typeof a.body=="string"?a.body=o:a.body=new u.MarkdownString(o),a):e}return e}})}createCommentController(e,t,n){const o=c.handlePool++,i=new _(e,o,t,n);this._commentControllers.set(i.handle,i);const a=this._commentControllersByExtension.get(e.identifier)||[];return a.push(i),this._commentControllersByExtension.set(e.identifier,a),i.value}async $createCommentThreadTemplate(e,t,n,o){const i=this._commentControllers.get(e);i&&i.$createCommentThreadTemplate(t,n,o)}async $setActiveComment(e,t){const n=this._commentControllers.get(e);n&&n.$setActiveComment(t??void 0)}async $updateCommentThreadTemplate(e,t,n){const o=this._commentControllers.get(e);o&&o.$updateCommentThreadTemplate(t,n)}$deleteCommentThread(e,t){this._commentControllers.get(e)?.$deleteCommentThread(t)}async $updateCommentThread(e,t,n){this._commentControllers.get(e)?.$updateCommentThread(t,n)}async $provideCommentingRanges(e,t,n){const o=this._commentControllers.get(e);if(!o||!o.commentingRangeProvider)return Promise.resolve(void 0);const i=await b.ensureDocumentData(x.revive(t));return D(async()=>{const a=await o.commentingRangeProvider.provideCommentingRanges(i.document,n);let l;return Array.isArray(a)?l={ranges:a,fileComments:!1}:a?l={ranges:a.ranges||[],fileComments:a.enableFileComments||!1}:l=a??void 0,l}).then(a=>{let l;return a&&(l={ranges:a.ranges.map(f=>g.Range.from(f)),fileComments:a.fileComments}),l})}$toggleReaction(e,t,n,o,i){const a=this._commentControllers.get(e);return!a||!a.reactionHandler?Promise.resolve(void 0):D(()=>{const l=a.getCommentThread(t);if(l){const f=l.getCommentByUniqueId(o.uniqueIdInThread);if(a!==void 0&&f&&a.reactionHandler)return a.reactionHandler(f,U(i))}return Promise.resolve(void 0)})}}const R=class R{constructor(e,t,n,o,i,a,l,f,A){this._commentControllerHandle=t;this._id=n;this._uri=o;this._range=i;this._comments=a;this.extensionDescription=l;this._isTemplate=f;this._acceptInputDisposables.value=new P,this._id===void 0&&(this._id=`${e}.${this.handle}`),d.$createCommentThread(t,this.handle,this._id,this._uri,g.Range.from(this._range),this._comments.map(m=>H(this,m,this._commentsMap,this.extensionDescription)),l.identifier,this._isTemplate,A),this._localDisposables=[],this._isDiposed=!1,this._localDisposables.push(this.onDidUpdateCommentThread(()=>{this.eventuallyUpdateCommentThread()})),this._localDisposables.push({dispose:()=>{d.$deleteCommentThread(t,this.handle)}});const s=this;this.value={get uri(){return s.uri},get range(){return s.range},set range(m){s.range=m},get comments(){return s.comments},set comments(m){s.comments=m},get collapsibleState(){return s.collapsibleState},set collapsibleState(m){s.collapsibleState=m},get canReply(){return s.canReply},set canReply(m){s.canReply=m},get contextValue(){return s.contextValue},set contextValue(m){s.contextValue=m},get label(){return s.label},set label(m){s.label=m},get state(){return s.state},set state(m){s.state=m},reveal:(m,q)=>s.reveal(m,q),hide:()=>s.hide(),dispose:()=>{s.dispose()}}}static _handlePool=0;handle=R._handlePool++;commentHandle=0;modifications=Object.create(null);set threadId(e){this._id=e}get threadId(){return this._id}get id(){return this._id}get resource(){return this._uri}get uri(){return this._uri}_onDidUpdateCommentThread=new B;onDidUpdateCommentThread=this._onDidUpdateCommentThread.event;set range(e){(e===void 0!=(this._range===void 0)||!e||!this._range||!e.isEqual(this._range))&&(this._range=e,this.modifications.range=e,this._onDidUpdateCommentThread.fire())}get range(){return this._range}_canReply=!0;set canReply(e){this._canReply!==e&&(this._canReply=e,this.modifications.canReply=e,this._onDidUpdateCommentThread.fire())}get canReply(){return this._canReply}_label;get label(){return this._label}set label(e){this._label=e,this.modifications.label=e,this._onDidUpdateCommentThread.fire()}_contextValue;get contextValue(){return this._contextValue}set contextValue(e){this._contextValue=e,this.modifications.contextValue=e,this._onDidUpdateCommentThread.fire()}get comments(){return this._comments}set comments(e){this._comments=e,this.modifications.comments=e,this._onDidUpdateCommentThread.fire()}_collapseState;get collapsibleState(){return this._collapseState}set collapsibleState(e){this._collapseState=e,this.modifications.collapsibleState=e,this._onDidUpdateCommentThread.fire()}_state;get state(){return this._state}set state(e){this._state=e,typeof e=="object"?(C(this.extensionDescription,"commentThreadApplicability"),this.modifications.state=e.resolved,this.modifications.applicability=e.applicability):this.modifications.state=e,this._onDidUpdateCommentThread.fire()}_localDisposables;_isDiposed;get isDisposed(){return this._isDiposed}_commentsMap=new Map;_acceptInputDisposables=new j;value;updateIsTemplate(){this._isTemplate&&(this._isTemplate=!1,this.modifications.isTemplate=!1)}eventuallyUpdateCommentThread(){if(this._isDiposed)return;this.updateIsTemplate(),this._acceptInputDisposables.value||(this._acceptInputDisposables.value=new P);const e=n=>Object.prototype.hasOwnProperty.call(this.modifications,n),t={};e("range")&&(t.range=g.Range.from(this._range)),e("label")&&(t.label=this.label),e("contextValue")&&(t.contextValue=this.contextValue??null),e("comments")&&(t.comments=this._comments.map(n=>H(this,n,this._commentsMap,this.extensionDescription))),e("collapsibleState")&&(t.collapseState=S(this._collapseState)),e("canReply")&&(t.canReply=this.canReply),e("state")&&(t.state=$(this._state)),e("applicability")&&(t.applicability=M(this._state)),e("isTemplate")&&(t.isTemplate=this._isTemplate),this.modifications={},d.$updateCommentThread(this._commentControllerHandle,this.handle,this._id,this._uri,t)}getCommentByUniqueId(e){for(const t of this._commentsMap){const n=t[0],o=t[1];if(e===o)return n}}async reveal(e,t){C(this.extensionDescription,"commentReveal");let n;e&&e.body!==void 0?n=e:t=t??e;let o=n?this._commentsMap.get(n):void 0;o??=this._commentsMap.get(this._comments[0]);let i=!0,a=!1;return t?.focus===u.CommentThreadFocus.Reply?(a=!0,i=!1):t?.focus===u.CommentThreadFocus.Comment&&(i=!1),d.$revealCommentThread(this._commentControllerHandle,this.handle,o,{preserveFocus:i,focusReply:a})}async hide(){return d.$hideCommentThread(this._commentControllerHandle,this.handle)}dispose(){this._isDiposed=!0,this._acceptInputDisposables.dispose(),this._localDisposables.forEach(e=>e.dispose())}};I([O(100)],R.prototype,"eventuallyUpdateCommentThread",1);let p=R;class _{constructor(e,t,n,o){this._extension=e;this._handle=t;this._id=n;this._label=o;d.$registerCommentController(this.handle,n,o,this._extension.identifier.value);const i=this;this.value=Object.freeze({id:i.id,label:i.label,get options(){return i.options},set options(a){i.options=a},get commentingRangeProvider(){return i.commentingRangeProvider},set commentingRangeProvider(a){i.commentingRangeProvider=a},get reactionHandler(){return i.reactionHandler},set reactionHandler(a){i.reactionHandler=a},get activeCommentThread(){return i.activeCommentThread},createCommentThread(a,l,f){return i.createCommentThread(a,l,f).value},dispose:()=>{i.dispose()}}),this._localDisposables=[],this._localDisposables.push({dispose:()=>{d.$unregisterCommentController(this.handle)}})}get id(){return this._id}get label(){return this._label}get handle(){return this._handle}_threads=new Map;_commentingRangeProvider;get commentingRangeProvider(){return this._commentingRangeProvider}set commentingRangeProvider(e){this._commentingRangeProvider=e,e?.resourceHints&&C(this._extension,"commentingRangeHint"),d.$updateCommentingRanges(this.handle,e?.resourceHints)}_reactionHandler;get reactionHandler(){return this._reactionHandler}set reactionHandler(e){this._reactionHandler=e,d.$updateCommentControllerFeatures(this.handle,{reactionHandler:!!e})}_options;get options(){return this._options}set options(e){this._options=e,d.$updateCommentControllerFeatures(this.handle,{options:this._options})}_activeComment;get activeComment(){return C(this._extension,"activeComment"),this._activeComment}_activeThread;get activeCommentThread(){return C(this._extension,"activeComment"),this._activeThread?.value}_localDisposables;value;createCommentThread(e,t,n){t===void 0&&C(this._extension,"fileComments");const o=new p(this.id,this.handle,void 0,e,t,n,this._extension,!1);return this._threads.set(o.handle,o),o}$setActiveComment(e){if(!e){this._activeComment=void 0,this._activeThread=void 0;return}const t=this._threads.get(e.commentThreadHandle);t&&(this._activeComment=e.uniqueIdInThread?t.getCommentByUniqueId(e.uniqueIdInThread):void 0,this._activeThread=t)}$createCommentThreadTemplate(e,t,n){const o=new p(this.id,this.handle,void 0,x.revive(e),g.Range.to(t),[],this._extension,!0,n);return o.collapsibleState=h.CommentThreadCollapsibleState.Expanded,this._threads.set(o.handle,o),o}$updateCommentThreadTemplate(e,t){const n=this._threads.get(e);n&&(n.range=g.Range.to(t))}$updateCommentThread(e,t){const n=this._threads.get(e);if(!n)return;(i=>Object.prototype.hasOwnProperty.call(t,i))("collapseState")&&(n.collapsibleState=S(t.collapseState))}$deleteCommentThread(e){this._threads.get(e)?.dispose(),this._threads.delete(e)}getCommentThread(e){return this._threads.get(e)}dispose(){this._threads.forEach(e=>{e.dispose()}),this._localDisposables.forEach(e=>e.dispose())}}function H(r,e,t,n){let o=t.get(e);return o||(o=++r.commentHandle,t.set(e,o)),e.state!==void 0&&C(n,"commentsDraftState"),e.reactions?.some(i=>i.reactors!==void 0)&&C(n,"commentReactor"),{mode:e.mode,contextValue:e.contextValue,uniqueIdInThread:o,body:typeof e.body=="string"?e.body:g.MarkdownString.from(e.body),userName:e.author.name,userIconPath:e.author.iconPath,label:e.label,commentReactions:e.reactions?e.reactions.map(i=>E(i)):void 0,state:e.state,timestamp:e.timestamp?.toJSON()}}function E(r){return{label:r.label,iconPath:r.iconPath?g.pathOrURIToURI(r.iconPath):void 0,count:r.count,hasReacted:r.authorHasReacted,reactors:r.reactors&&r.reactors.length>0&&typeof r.reactors[0]!="string"?r.reactors.map(e=>e.name):r.reactors}}function U(r){return{label:r.label||"",count:r.count||0,iconPath:r.iconPath?x.revive(r.iconPath):"",authorHasReacted:r.hasReacted||!1,reactors:r.reactors?.map(e=>({name:e}))}}function S(r){if(r!==void 0)switch(r){case u.CommentThreadCollapsibleState.Expanded:return h.CommentThreadCollapsibleState.Expanded;case u.CommentThreadCollapsibleState.Collapsed:return h.CommentThreadCollapsibleState.Collapsed}return h.CommentThreadCollapsibleState.Collapsed}function $(r){let e;if(typeof r=="object"?e=r.resolved:e=r,e!==void 0)switch(e){case u.CommentThreadState.Unresolved:return h.CommentThreadState.Unresolved;case u.CommentThreadState.Resolved:return h.CommentThreadState.Resolved}return h.CommentThreadState.Unresolved}function M(r){let e;if(typeof r=="object"&&(e=r.applicability),e!==void 0)switch(e){case u.CommentThreadApplicability.Current:return h.CommentThreadApplicability.Current;case u.CommentThreadApplicability.Outdated:return h.CommentThreadApplicability.Outdated}return h.CommentThreadApplicability.Current}return new c}export{Ce as createExtHostComments};
