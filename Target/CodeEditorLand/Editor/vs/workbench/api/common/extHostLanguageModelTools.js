import{raceCancellation as l}from"../../../base/common/async.js";import{CancellationToken as c}from"../../../base/common/cancellation.js";import{CancellationError as g}from"../../../base/common/errors.js";import{toDisposable as u}from"../../../base/common/lifecycle.js";import{revive as T}from"../../../base/common/marshalling.js";import{generateUuid as d}from"../../../base/common/uuid.js";import"../../../platform/extensions/common/extensions.js";import"../../contrib/chat/common/languageModelToolsService.js";import{MainContext as p}from"./extHost.protocol.js";import*as i from"./extHostTypeConverters.js";class F{_registeredTools=new Map;_proxy;_tokenCountFuncs=new Map;_allTools=new Map;constructor(o){this._proxy=o.getProxy(p.MainThreadLanguageModelTools),this._proxy.$getTools().then(e=>{for(const n of e)this._allTools.set(n.id,T(n))})}async $countTokensForInvocation(o,e,n){const t=this._tokenCountFuncs.get(o);if(!t)throw new Error(`Tool invocation call ${o} not found`);return await t(e,n)}async invokeTool(o,e,n){if(!e.requestedContentTypes?.length)throw new Error("LanguageModelToolInvocationOptions.requestedContentTypes is required to be set");const t=d();e.tokenOptions&&this._tokenCountFuncs.set(t,e.tokenOptions.countTokens);try{return await this._proxy.$invokeTool({toolId:o,callId:t,parameters:e.parameters,tokenBudget:e.tokenOptions?.tokenBudget,context:e.toolInvocationToken,requestedContentTypes:e.requestedContentTypes},n)}finally{this._tokenCountFuncs.delete(t)}}$onDidChangeTools(o){this._allTools.clear();for(const e of o)this._allTools.set(e.id,e)}get tools(){return Array.from(this._allTools.values()).map(o=>i.LanguageModelToolDescription.to(o))}async $invokeTool(o,e){const n=this._registeredTools.get(o.toolId);if(!n)throw new Error(`Unknown tool ${o.toolId}`);const t={parameters:o.parameters,toolInvocationToken:o.context,requestedContentTypes:o.requestedContentTypes};o.tokenBudget!==void 0&&(t.tokenOptions={tokenBudget:o.tokenBudget,countTokens:this._tokenCountFuncs.get(o.callId)||((r,a=c.None)=>this._proxy.$countTokensForInvocation(o.callId,r,a))});const s=await l(Promise.resolve(n.tool.invoke(t,e)),e);if(!s)throw new g;for(const r of Object.keys(s)){if(s[r]instanceof Promise)throw new Error(`Tool result for '${r}' cannot be a Promise`);if(!t.requestedContentTypes.includes(r)&&r!=="toString")throw new Error(`Tool result for '${r}' was not requested from ${o.toolId}.`)}return s}async $prepareToolInvocation(o,e,n){const t=this._registeredTools.get(o);if(!t)throw new Error(`Unknown tool ${o}`);if(!t.tool.prepareToolInvocation)return;const s=await t.tool.prepareToolInvocation({parameters:e},n);if(s)return{confirmationMessages:s.confirmationMessages?{title:s.confirmationMessages.title,message:typeof s.confirmationMessages.message=="string"?s.confirmationMessages.message:i.MarkdownString.from(s.confirmationMessages.message)}:void 0,invocationMessage:s.invocationMessage}}registerTool(o,e,n){return this._registeredTools.set(e,{extension:o,tool:n}),this._proxy.$registerTool(e),u(()=>{this._registeredTools.delete(e),this._proxy.$unregisterTool(e)})}}export{F as ExtHostLanguageModelTools};
