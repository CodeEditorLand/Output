var W=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var v=(S,o,e,t)=>{for(var i=t>1?void 0:t?B(o,e):o,s=S.length-1,r;s>=0;s--)(r=S[s])&&(i=(t?r(o,e,i):r(i))||i);return t&&i&&W(o,e,i),i},a=(S,o)=>(e,t)=>o(e,t,S);import{Sequencer as j}from"../../../../base/common/async.js";import{CancellationTokenSource as K}from"../../../../base/common/cancellation.js";import{BugIndicatingError as E}from"../../../../base/common/errors.js";import{Emitter as b}from"../../../../base/common/event.js";import{Disposable as w,DisposableStore as x}from"../../../../base/common/lifecycle.js";import{ResourceSet as L}from"../../../../base/common/map.js";import{derived as $,observableValue as _,ValueWithChangeEventFromObservable as H}from"../../../../base/common/observable.js";import{URI as R}from"../../../../base/common/uri.js";import{isCodeEditor as J,isDiffEditor as z}from"../../../../editor/browser/editorBrowser.js";import{IBulkEditService as P}from"../../../../editor/browser/services/bulkEditService.js";import"../../../../editor/common/languages.js";import{ILanguageService as Q}from"../../../../editor/common/languages/language.js";import"../../../../editor/common/model.js";import{createTextBufferFactoryFromSnapshot as X}from"../../../../editor/common/model/textModel.js";import{IModelService as A}from"../../../../editor/common/services/model.js";import{ITextModelService as O}from"../../../../editor/common/services/resolverService.js";import{localize as F,localize2 as Y}from"../../../../nls.js";import{IContextKeyService as Z}from"../../../../platform/contextkey/common/contextkey.js";import{EditorActivation as D}from"../../../../platform/editor/common/editor.js";import{IInstantiationService as T}from"../../../../platform/instantiation/common/instantiation.js";import{bindContextKey as U}from"../../../../platform/observable/common/platformObservableUtils.js";import{IProgressService as ee,ProgressLocation as te}from"../../../../platform/progress/common/progress.js";import{DiffEditorInput as ie}from"../../../common/editor/diffEditorInput.js";import"../../../common/editor/editorInput.js";import{IEditorGroupsService as G}from"../../../services/editor/common/editorGroupsService.js";import{IEditorService as N}from"../../../services/editor/common/editorService.js";import"../../multiDiffEditor/browser/multiDiffEditor.js";import{MultiDiffEditorInput as k}from"../../multiDiffEditor/browser/multiDiffEditorInput.js";import{IMultiDiffSourceResolverService as se,MultiDiffEditorItem as re}from"../../multiDiffEditor/browser/multiDiffSourceResolverService.js";import{ICodeMapperService as oe}from"../common/chatCodeMapperService.js";import{applyingChatEditsContextKey as ne,CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME as ae,chatEditingResourceContextKey as de,ChatEditingSessionState as h,decidedChatEditingResourceContextKey as ce,inChatEditingSessionContextKey as q,WorkingSetEntryState as m}from"../common/chatEditingService.js";import"../common/chatModel.js";import{IChatService as V}from"../common/chatService.js";import{IChatWidgetService as le}from"./chat.js";let C=class extends w{constructor(e,t,i,s,r,c,n,u,g){super();this._editorGroupsService=e;this._instantiationService=t;this._chatService=c;this._progressService=n;this._codeMapperService=u;this._editorService=g;this._register(i.registerResolver(t.createInstance(l,this._currentSessionObs))),s.registerTextModelContentProvider(p.scheme,t.createInstance(p,this._currentSessionObs)),this._register(U(ce,r,d=>{const I=this._currentSessionObs.read(d);return I?I.entries.read(d).filter(M=>M.state.read(d)!==m.Modified).map(M=>M.entryId):void 0})),this._register(U(q,r,d=>this._currentSessionObs.read(d)!==null)),this._register(U(ne,r,d=>this._currentAutoApplyOperationObs.read(d)!==null)),this._register(this._chatService.onDidDisposeSession(d=>{d.reason==="cleared"&&this._currentSessionObs.get()?.chatSessionId===d.sessionId&&this._currentSessionObs.get()?.stop()}))}_serviceBrand;_currentSessionObs=_(this,null);_currentSessionDisposables=this._register(new x);_currentAutoApplyOperationObs=_(this,null);get currentAutoApplyOperation(){return this._currentAutoApplyOperationObs.get()}get currentEditingSession(){return this._currentSessionObs.get()}_onDidCreateEditingSession=this._register(new b);get onDidCreateEditingSession(){return this._onDidCreateEditingSession.event}_onDidChangeEditingSession=this._register(new b);onDidChangeEditingSession=this._onDidChangeEditingSession.event;getEditingSession(e){const t=this.currentEditingSession;if(!t)return null;const i=t.entries.get();for(const s of i)if(s.modifiedURI.toString()===e.toString())return t;return null}async addFileToWorkingSet(e){const t=this._currentSessionObs.get();t&&t.addFileToWorkingSet(e)}dispose(){this._currentSessionObs.get()?.dispose(),super.dispose()}async startOrContinueEditingSession(e,t){const i=this._currentSessionObs.get();if(i&&i.chatSessionId!==e)throw new E("Cannot start new session while another session is active");return this._createEditingSession(e,t)}async _createEditingSession(e,t){if(this._currentSessionObs.get())throw new E("Cannot have more than one active editing session");this._currentSessionDisposables.clear(),this._currentSessionDisposables.add(this.installAutoApplyObserver(e));const i=k.fromResourceMultiDiffEditorInput({multiDiffSource:l.getMultiDiffSourceUri(),label:F("multiDiffEditorInput.name","Suggested Edits")},this._instantiationService),s=t?.silent?void 0:await this._editorGroupsService.activeGroup.openEditor(i,{pinned:!0,activation:D.ACTIVATE}),r=this._instantiationService.createInstance(y,e,s);return this._currentSessionDisposables.add(r.onDidDispose(()=>{this._currentSessionDisposables.clear(),this._currentSessionObs.set(null,void 0),this._onDidChangeEditingSession.fire()})),this._currentSessionDisposables.add(r.onDidChange(()=>{this._onDidChangeEditingSession.fire()})),this._currentSessionObs.set(r,void 0),this._onDidCreateEditingSession.fire(r),this._onDidChangeEditingSession.fire(),r}triggerEditComputation(e){return this._continueEditingSession(async(t,i)=>{const s={textEdit:(r,c)=>t.textEdits(r,c,e)};await this._codeMapperService.mapCodeFromResponse(e,s,i)},{silent:!0})}installAutoApplyObserver(e){const t=this._chatService.getSession(e);if(!t)throw new Error(`Edit session was created for a non-existing chat session: ${e}`);const i=new x,s=c=>{c.result?.metadata?.autoApplyEdits&&this.triggerEditComputation(c)},r=c=>{for(const n of c.response.value)n.kind==="codeblockUri"&&this._editorService.openEditor({resource:n.uri,options:{inactive:!0,preserveFocus:!0,pinned:!0}})};return i.add(t.onDidChange(c=>{if(c.kind==="addRequest"){const n=c.request.response;if(n)if(n.isComplete)r(n),s(n);else{const u=n.onDidChange(()=>{r(n),n.isComplete?(s(n),u.dispose()):(n.isCanceled||n.isStale)&&u.dispose()})}}})),i.add(t.onDidDispose(()=>i.dispose())),i}async _continueEditingSession(e,t){const i=this._currentSessionObs.get();if(!i)throw new E("Cannot continue missing session");if(i.state.get()===h.StreamingEdits)throw new E("Cannot continue session that is still streaming");let s;if(!t?.silent&&i.isVisible){const n=this._findGroupedEditors();if(n.length!==1)throw new Error(`Unexpected number of editors: ${n.length}`);const[u,g]=n[0];s=await u.openEditor(g,{pinned:!0,activation:D.ACTIVATE})}const r={textEdits:(n,u,g)=>{i.acceptTextEdits(n,u,g)}};i.acceptStreamingEditsStart();const c=new K;this._currentAutoApplyOperationObs.set(c,void 0);try{s?await s?.showWhile(e(r,c.token)):await this._progressService.withProgress({location:te.Window,title:Y("chatEditing.startingSession","Generating edits...").value},async()=>{await e(r,c.token)},()=>c.cancel())}finally{c.dispose(),this._currentAutoApplyOperationObs.set(null,void 0),i.resolve()}}_findGroupedEditors(){const e=[];for(const t of this._editorGroupsService.groups)for(const i of t.editors)i.resource?.scheme===l.scheme&&e.push([t,i]);return e}};C=v([a(0,G),a(1,T),a(2,se),a(3,O),a(4,Z),a(5,V),a(6,ee),a(7,oe),a(8,N)],C);let l=class{constructor(o,e){this._currentSession=o;this._instantiationService=e}static scheme=ae;static getMultiDiffSourceUri(){return R.from({scheme:l.scheme,path:""})}canHandleUri(o){return o.scheme===l.scheme}async resolveDiffSource(o){return this._instantiationService.createInstance(pe,this._currentSession)}};l=v([a(1,T)],l);class pe{constructor(o){this._currentSession=o}_resources=$(this,o=>{const e=this._currentSession.read(o);return e?e.entries.read(o).map(i=>new re(i.originalURI,i.modifiedURI,void 0,{[de.key]:i.entryId})):[]});resources=new H(this._resources);contextKeys={[q.key]:!0}}let p=class{constructor(o,e){this._currentSessionObs=o;this._modelService=e}static scheme="chat-editing-text-model";static getEmptyFileURI(){return R.from({scheme:p.scheme,query:JSON.stringify({kind:"empty"})})}static getFileURI(o,e){return R.from({scheme:p.scheme,path:e,query:JSON.stringify({kind:"doc",documentId:o})})}async provideTextContent(o){const e=this._modelService.getModel(o);if(e&&!e.isDisposed())return e;const t=JSON.parse(o.query);if(t.kind==="empty")return this._modelService.createModel("",null,o,!1);const i=this._currentSessionObs.get();return i?i.getVirtualModel(t.documentId):null}};p=v([a(1,A)],p);let y=class extends w{constructor(e,t,i,s,r,c,n,u){super();this.chatSessionId=e;this.editorPane=t;this._instantiationService=i;this._textModelService=s;this._bulkEditService=r;this._editorGroupsService=c;this._editorService=n;const g=u.getWidgetBySessionId(e);let d=this._editorService.activeTextEditorControl;if(d&&(z(d)&&(d=d.getOriginalEditor().hasTextFocus()?d.getOriginalEditor():d.getModifiedEditor()),J(d)&&d.hasModel())){const I=d.getModel().uri;this._workingSet.add(I),g?.attachmentModel.addFile(I),this._workingSetObs.set([...this._workingSet.values()],void 0)}}_state=_(this,h.Initial);_entriesObs=_(this,[]);get entries(){return this._assertNotDisposed(),this._entriesObs}_sequencer=new j;_entries=[];_workingSetObs=_(this,[]);_workingSet=new L;get workingSet(){return this._assertNotDisposed(),this._workingSetObs}get state(){return this._assertNotDisposed(),this._state}_onDidChange=new b;get onDidChange(){return this._assertNotDisposed(),this._onDidChange.event}_onDidDispose=new b;get onDidDispose(){return this._assertNotDisposed(),this._onDidDispose.event}get isVisible(){return this._assertNotDisposed(),!!(this.editorPane&&this.editorPane.isVisible())}remove(...e){this._assertNotDisposed();let t=!1;for(const i of e)t=t||this._workingSet.delete(i);t&&(this._workingSetObs.set([...this._workingSet.values()],void 0),this._onDidChange.fire())}_assertNotDisposed(){if(this._state.get()===h.Disposed)throw new E("Cannot access a disposed editing session")}async accept(...e){this._assertNotDisposed(),e.length===0&&await Promise.all(this._entries.map(t=>t.accept(void 0)));for(const t of e){const i=this._entries.find(s=>s.modifiedURI.toString()===t.toString());i&&await i.accept(void 0)}this._onDidChange.fire()}async reject(...e){this._assertNotDisposed(),e.length===0&&await Promise.all(this._entries.map(t=>t.reject(void 0)));for(const t of e){const i=this._entries.find(s=>s.modifiedURI.toString()===t.toString());i&&await i.reject(void 0)}this._onDidChange.fire()}async show(){if(this._assertNotDisposed(),this.editorPane?.isVisible())return;if(this.editorPane?.input){await this._editorGroupsService.activeGroup.openEditor(this.editorPane.input,{pinned:!0,activation:D.ACTIVATE});return}const e=k.fromResourceMultiDiffEditorInput({multiDiffSource:l.getMultiDiffSourceUri(),label:F("multiDiffEditorInput.name","Suggested Edits")},this._instantiationService),t=await this._editorGroupsService.activeGroup.openEditor(e,{pinned:!0,activation:D.ACTIVATE});this.editorPane=t}async stop(){this._assertNotDisposed(),await Promise.allSettled(this._editorGroupsService.groups.map(async e=>Promise.allSettled(e.editors.map(async t=>{(t instanceof k||t instanceof ie&&(t.original.resource?.scheme===f.scheme||t.original.resource?.scheme===p.scheme))&&await e.closeEditor(t)})))),this._state.get()!==h.Disposed&&this.dispose()}dispose(){this._assertNotDisposed(),super.dispose(),this._state.set(h.Disposed,void 0),this._onDidDispose.fire()}getVirtualModel(e){return this._assertNotDisposed(),this._entries.find(i=>i.entryId===e)?.docSnapshot??null}acceptStreamingEditsStart(){this._state.get()!==h.Disposed&&this._sequencer.queue(()=>this._acceptStreamingEditsStart())}acceptTextEdits(e,t,i){this._state.get()!==h.Disposed&&this._sequencer.queue(()=>this._acceptTextEdits(e,t,i))}resolve(){this._state.get()!==h.Disposed&&this._sequencer.queue(()=>this._resolve())}addFileToWorkingSet(e){this._workingSet.has(e)||(this._workingSet.add(e),this._workingSetObs.set([...this._workingSet.values()],void 0),this._onDidChange.fire())}async _acceptStreamingEditsStart(){this._state.set(h.StreamingEdits,void 0),this._onDidChange.fire()}async _acceptTextEdits(e,t,i){const s=await this._getOrCreateModifiedFileEntry(e,i);s.applyEdits(t),await this._editorService.openEditor({resource:s.modifiedURI,options:{inactive:!0}})}async _resolve(){this._state.set(h.Idle,void 0),this._onDidChange.fire()}async _getOrCreateModifiedFileEntry(e,t){const i=this._entries.find(r=>r.resource.toString()===e.toString());if(i)return i;const s=await this._createModifiedFileEntry(e,t);return this._register(s),this._entries=[...this._entries,s],this._entriesObs.set(this._entries,void 0),this._onDidChange.fire(),s}async _createModifiedFileEntry(e,t,i=!1){try{const s=await this._textModelService.createModelReference(e);return this._instantiationService.createInstance(f,e,s,{collapse:r=>this._collapse(e,r)},t)}catch(s){if(i)throw s;return await this._bulkEditService.apply({edits:[{newResource:e}]}),this._createModifiedFileEntry(e,t,!0)}}_collapse(e,t){const i=this.editorPane?.findDocumentDiffItem(e);i&&this.editorPane?.viewModel?.items.get().find(s=>String(s.originalUri)===String(i.originalUri)&&String(s.modifiedUri)===String(i.modifiedUri))?.collapsed.set(!0,t)}};y=v([a(2,T),a(3,O),a(4,P),a(5,G),a(6,N),a(7,le)],y);let f=class extends w{constructor(e,t,i,s,r,c,n,u,g){super();this.resource=e;this._multiDiffEntryDelegate=i;this._responseModel=s;this.bulkEditService=u;this._chatService=g;this.doc=t.object.textEditorModel;const d=this.docSnapshot=this._register(r.createModel(X(this.doc.createSnapshot()),n.createById(this.doc.getLanguageId()),p.getFileURI(this.entryId,e.path),!1));(async()=>this._register(await c.createModelReference(d.uri)))(),this._register(t)}static scheme="modified-file-entry";static lastEntryId=0;entryId=`${f.scheme}::${++f.lastEntryId}`;docSnapshot;doc;get originalURI(){return this.docSnapshot.uri}get originalModel(){return this.docSnapshot}get modifiedURI(){return this.doc.uri}_stateObs=_(this,m.Modified);get state(){return this._stateObs}applyEdits(e){this.doc.applyEdits(e),this._stateObs.set(m.Modified,void 0)}async accept(e){this._stateObs.get()===m.Modified&&(this.docSnapshot.setValue(this.doc.createSnapshot()),this._stateObs.set(m.Accepted,e),await this.collapse(e),this._notifyAction("accepted"))}async reject(e){this._stateObs.get()===m.Modified&&(this.doc.setValue(this.docSnapshot.createSnapshot()),this._stateObs.set(m.Rejected,e),await this.collapse(e),this._notifyAction("rejected"))}async collapse(e){this._multiDiffEntryDelegate.collapse(e)}_notifyAction(e){this._chatService.notifyUserAction({action:{kind:"chatEditingSessionAction",uri:this.resource,hasRemainingEdits:!1,outcome:e},agentId:this._responseModel.agent?.id,command:this._responseModel.slashCommand?.name,sessionId:this._responseModel.session.sessionId,requestId:this._responseModel.requestId,result:this._responseModel.result})}};f=v([a(4,A),a(5,O),a(6,Q),a(7,P),a(8,V)],f);export{C as ChatEditingService};
