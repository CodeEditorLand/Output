var y=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var h=(s,i,n,a)=>{for(var r=a>1?void 0:a?b(i,n):i,t=s.length-1,e;t>=0;t--)(e=s[t])&&(r=(a?e(i,n,r):e(r))||r);return a&&r&&y(i,n,r),r},m=(s,i)=>(n,a)=>i(n,a,s);import"../../../../../base/common/jsonSchema.js";import{DisposableMap as w}from"../../../../../base/common/lifecycle.js";import{joinPath as p}from"../../../../../base/common/resources.js";import{ThemeIcon as I}from"../../../../../base/common/themables.js";import{localize as o}from"../../../../../nls.js";import{ContextKeyExpr as x}from"../../../../../platform/contextkey/common/contextkey.js";import"../../../../../platform/extensions/common/extensions.js";import{ILogService as N}from"../../../../../platform/log/common/log.js";import"../../../../common/contributions.js";import{ILanguageModelToolsService as T}from"../languageModelToolsService.js";import*as D from"../../../../services/extensions/common/extensionsRegistry.js";const v=D.ExtensionsRegistry.registerExtensionPoint({extensionPoint:"languageModelTools",activationEventsGenerator:(s,i)=>{for(const n of s)i.push(`onLanguageModelTool:${n.name}`)},jsonSchema:{description:o("vscode.extension.contributes.tools","Contributes a tool that can be invoked by a language model in a chat session, or from a standalone command. Registered tools can be used by all extensions."),type:"array",items:{additionalProperties:!1,type:"object",defaultSnippets:[{body:{name:"",description:""}}],required:["name","displayName","modelDescription"],properties:{name:{description:o("toolName","A unique name for this tool. This name must be a globally unique identifier, and is also used as a name when presenting this tool to a language model."),type:"string",pattern:"^[\\w-]+$"},toolReferenceName:{markdownDescription:o("toolName2","If {0} is enabled for this tool, the user may use '#' with this name to invoke the tool in a query. Otherwise, the name is not required. Name must not contain whitespace.","`canBeReferencedInPrompt`"),type:"string",pattern:"^[\\w-]+$"},displayName:{description:o("toolDisplayName","A human-readable name for this tool that may be used to describe it in the UI."),type:"string"},userDescription:{description:o("toolUserDescription","A description of this tool that may be shown to the user."),type:"string"},modelDescription:{description:o("toolModelDescription","A description of this tool that may be used by a language model to select it."),type:"string"},parametersSchema:{description:o("parametersSchema","A JSON schema for the parameters this tool accepts."),type:"object",$ref:"http://json-schema.org/draft-07/schema#"},canBeReferencedInPrompt:{markdownDescription:o("canBeReferencedInPrompt","If true, this tool shows up as an attachment that the user can add manually to their request. Chat participants will receive the tool in {0}.","`ChatRequest#toolReferences`"),type:"boolean"},icon:{markdownDescription:o("icon","An icon that represents this tool. Either a file path, an object with file paths for dark and light themes, or a theme icon reference, like `$(zap)`"),anyOf:[{type:"string"},{type:"object",properties:{light:{description:o("icon.light","Icon path when a light theme is used"),type:"string"},dark:{description:o("icon.dark","Icon path when a dark theme is used"),type:"string"}}}]},when:{markdownDescription:o("condition","Condition which must be true for this tool to be enabled. Note that a tool may still be invoked by another extension even when its `when` condition is false."),type:"string"},supportedContentTypes:{markdownDescription:o("contentTypes","The list of content types that this tool can return. It's recommended that all tools support `text/plain`, which would indicate any text-based content. Another example is the contentType exported by the `@vscode/prompt-tsx` library, which would let a tool return a `PromptElementJSON` which can be easily rendered in a prompt by an extension using `@vscode/prompt-tsx`."),type:"array",items:{type:"string"}},tags:{description:o("toolTags","A set of tags that roughly describe the tool's capabilities. A tool user may use these to filter the set of tools to just ones that are relevant for the task at hand."),type:"array",items:{type:"string"}}}}}});function f(s,i){return`${s.value}/${i}`}let l=class{static ID="workbench.contrib.toolsExtensionPointHandler";_registrationDisposables=new w;constructor(i,n){v.setHandler((a,r)=>{for(const t of r.added)for(const e of t.value){if(!e.name||!e.modelDescription||!e.displayName){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool without name, modelDescription, and displayName: ${JSON.stringify(e)}`);continue}if(!e.name.match(/^[\w-]+$/)){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool with invalid id: ${e.name}. The id must match /^[\\w-]+$/.`);continue}if(e.canBeReferencedInPrompt&&!e.toolReferenceName){n.error(`Extension '${t.description.identifier.value}' CANNOT register tool with 'canBeReferencedInPrompt' set without a 'toolReferenceName': ${JSON.stringify(e)}`);continue}const c=e.icon;let d;typeof c=="string"?d=I.fromString(c)??{dark:p(t.description.extensionLocation,c),light:p(t.description.extensionLocation,c)}:c&&(d={dark:p(t.description.extensionLocation,c.dark),light:p(t.description.extensionLocation,c.light)});const u={...e,id:e.name,icon:d,when:e.when?x.deserialize(e.when):void 0,supportedContentTypes:e.supportedContentTypes?e.supportedContentTypes:[]},g=i.registerToolData(u);this._registrationDisposables.set(f(t.description.identifier,e.name),g)}for(const t of r.removed)for(const e of t.value)this._registrationDisposables.deleteAndDispose(f(t.description.identifier,e.name))})}};l=h([m(0,T),m(1,N)],l);export{l as LanguageModelToolsExtensionPointHandler};
