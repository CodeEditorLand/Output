var z=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var A=(k,c,e,i)=>{for(var r=i>1?void 0:i?B(c,e):c,t=k.length-1,o;t>=0;t--)(o=k[t])&&(r=(i?o(c,e,r):o(r))||r);return i&&r&&z(c,e,r),r},g=(k,c)=>(e,i)=>c(e,i,k);import{Action as F}from"../../../../base/common/actions.js";import{disposableTimeout as D}from"../../../../base/common/async.js";import{CancellationTokenSource as P}from"../../../../base/common/cancellation.js";import{createErrorWithActions as N}from"../../../../base/common/errorMessage.js";import{Emitter as O,Event as R}from"../../../../base/common/event.js";import{DisposableStore as K}from"../../../../base/common/lifecycle.js";import C from"../../../../base/common/severity.js";import*as a from"../../../../nls.js";import{ICommandService as V}from"../../../../platform/commands/common/commands.js";import{IConfigurationService as G}from"../../../../platform/configuration/common/configuration.js";import{IDialogService as U}from"../../../../platform/dialogs/common/dialogs.js";import{IMarkerService as Y,MarkerSeverity as q}from"../../../../platform/markers/common/markers.js";import{IProgressService as J,ProgressLocation as H}from"../../../../platform/progress/common/progress.js";import{IStorageService as j,StorageScope as _,StorageTarget as Q}from"../../../../platform/storage/common/storage.js";import"../../../../platform/workspace/common/workspace.js";import{DEBUG_CONFIGURE_COMMAND_ID as x,DEBUG_CONFIGURE_LABEL as X}from"./debugCommands.js";import"../common/debug.js";import{Markers as L}from"../../markers/common/markers.js";import{ConfiguringTask as Z,CustomTask as $,TaskEventKind as h}from"../../tasks/common/tasks.js";import{ITaskService as ee}from"../../tasks/common/taskService.js";import{IViewsService as re}from"../../../services/views/common/viewsService.js";const w=(k,c)=>R.once(R.filter(k,c));var ie=(e=>(e[e.Failure=0]="Failure",e[e.Success=1]="Success",e))(ie||{});const W="debug.taskerrorchoice",M=a.localize("abort","Abort"),oe=a.localize({key:"debugAnyway",comment:["&& denotes a mnemonic"]},"&&Debug Anyway"),ne=a.localize("debugAnywayNoMemo","Debug Anyway");let y=class{constructor(c,e,i,r,t,o,u,l){this.taskService=c;this.markerService=e;this.configurationService=i;this.viewsService=r;this.dialogService=t;this.storageService=o;this.commandService=u;this.progressService=l}globalCancellation=new P;cancel(){this.globalCancellation.dispose(!0),this.globalCancellation=new P}dispose(){this.globalCancellation.dispose(!0)}async runTaskAndCheckErrors(c,e){try{const i=await this.runTask(c,e,this.globalCancellation.token);if(i&&(i.exitCode===void 0||i.cancelled))return 0;const r=e?this.markerService.read({severities:q.Error,take:2}).length:0,t=i&&i.exitCode===0,o=i&&i.exitCode!==0,u=this.configurationService.getValue("debug").onTaskErrors;if(t||u==="debugAnyway"||r===0&&!o)return 1;if(u==="showErrors")return await this.viewsService.openView(L.MARKERS_VIEW_ID,!0),Promise.resolve(0);if(u==="abort")return Promise.resolve(0);const l=typeof e=="string"?e:e?e.name:"",p=r>1?a.localize("preLaunchTaskErrors","Errors exist after running preLaunchTask '{0}'.",l):r===1?a.localize("preLaunchTaskError","Error exists after running preLaunchTask '{0}'.",l):i&&typeof i.exitCode=="number"?a.localize("preLaunchTaskExitCode","The preLaunchTask '{0}' terminated with exit code {1}.",l,i.exitCode):a.localize("preLaunchTaskTerminated","The preLaunchTask '{0}' terminated.",l);let S;(f=>(f[f.DebugAnyway=1]="DebugAnyway",f[f.ShowErrors=2]="ShowErrors",f[f.Cancel=0]="Cancel"))(S||={});const{result:m,checkboxChecked:v}=await this.dialogService.prompt({type:C.Warning,message:p,buttons:[{label:oe,run:()=>1},{label:a.localize({key:"showErrors",comment:["&& denotes a mnemonic"]},"&&Show Errors"),run:()=>2}],cancelButton:{label:M,run:()=>0},checkbox:{label:a.localize("remember","Remember my choice in user settings")}}),n=m===1,s=m===0;return v&&this.configurationService.updateValue("debug.onTaskErrors",m===1?"debugAnyway":s?"abort":"showErrors"),s?Promise.resolve(0):n?1:(await this.viewsService.openView(L.MARKERS_VIEW_ID,!0),Promise.resolve(0))}catch(i){const r=this.taskService.configureAction(),t=JSON.parse(this.storageService.get(W,_.WORKSPACE,"{}"));let o=-1,u;if((m=>(m[m.DebugAnyway=0]="DebugAnyway",m[m.ConfigureTask=1]="ConfigureTask",m[m.Cancel=2]="Cancel"))(u||={}),t[i.message]!==void 0)o=t[i.message];else{const{result:l,checkboxChecked:p}=await this.dialogService.prompt({type:C.Error,message:i.message,buttons:[{label:a.localize({key:"debugAnyway",comment:["&& denotes a mnemonic"]},"&&Debug Anyway"),run:()=>0},{label:r.label,run:()=>1}],cancelButton:{run:()=>2},checkbox:{label:a.localize("rememberTask","Remember my choice for this task")}});o=l,p&&(t[i.message]=o,this.storageService.store(W,JSON.stringify(t),_.WORKSPACE,Q.MACHINE))}return o===1&&await r.run(),o===0?1:0}}async runTask(c,e,i=this.globalCancellation.token){if(!e)return Promise.resolve(null);if(!c)return Promise.reject(new Error(a.localize("invalidTaskReference","Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",typeof e=="string"?e:e.type)));const r=await this.taskService.getTask(c,e);if(!r){const n=typeof e=="string"?a.localize("DebugTaskNotFoundWithTaskId","Could not find the task '{0}'.",e):a.localize("DebugTaskNotFound","Could not find the specified task.");return Promise.reject(N(n,[new F(x,X,void 0,!0,()=>this.commandService.executeCommand(x))]))}let t=!1;const o=new K,u=n=>n.getKey()??n.getMapKey(),l=u(r),p=new Promise(n=>o.add(w(this.taskService.onDidStateChange,s=>(s.kind===h.Inactive||s.kind===h.ProcessEnded&&s.exitCode===void 0)&&u(s.__task)===l)(s=>{t=!0,n(s.kind===h.ProcessEnded?{exitCode:s.exitCode}:null)})));o.add(w(this.taskService.onDidStateChange,n=>(n.kind===h.Active||n.kind===h.DependsOnStarted)&&u(n.__task)===l)(()=>{t=!0}));const S=o.add(new O);o.add(w(this.taskService.onDidStateChange,n=>n.kind===h.AcquiredInput&&u(n.__task)===l)(()=>S.fire()));const m=this.taskService.getActiveTasks().then(async n=>{if(n.find(d=>u(d)===l))return S.fire(),(await this.taskService.getBusyTasks()).find(E=>u(E)===l)?(t=!0,p):Promise.resolve(null);const s=this.taskService.run(r);return r.configurationProperties.isBackground?p:s.then(d=>d??null)}),v=new Promise((n,s)=>{m.then(d=>{t=!0,n(d)},d=>s(d)),o.add(i.onCancellationRequested(()=>{n({exitCode:void 0,cancelled:!0}),this.taskService.terminate(r).catch(()=>{})})),o.add(S.event(()=>{const d=r.configurationProperties.isBackground?5e3:1e4;o.add(D(()=>{if(!t){const T=a.localize("taskNotTracked","The task '{0}' has not exited and doesn't have a 'problemMatcher' defined. Make sure to define a problem matcher for watch tasks.",typeof e=="string"?e:JSON.stringify(e));s({severity:C.Error,message:T})}},d)),this.configurationService.getValue("debug").hideSlowPreLaunchWarning||o.add(D(()=>{const T=a.localize("runningTask","Waiting for preLaunchTask '{0}'...",r.configurationProperties.name),f=[ne,M],I=r instanceof $||r instanceof Z;I&&f.splice(1,0,a.localize("configureTask","Configure Task")),this.progressService.withProgress({location:H.Notification,title:T,buttons:f},()=>v.catch(()=>{}),b=>{b===void 0||(b===0?n({exitCode:0}):(n({exitCode:void 0,cancelled:!0}),this.taskService.terminate(r).catch(()=>{}),I&&b===1&&this.taskService.openConfig(r)))})},1e4))}))});return v.finally(()=>o.dispose())}};y=A([g(0,ee),g(1,Y),g(2,G),g(3,re),g(4,U),g(5,j),g(6,V),g(7,J)],y);export{y as DebugTaskRunner,ie as TaskRunResult};
