var Q=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var f=(d,c,e,s)=>{for(var t=s>1?void 0:s?k(c,e):c,a=d.length-1,r;a>=0;a--)(r=d[a])&&(t=(s?r(c,e,t):r(t))||t);return s&&t&&Q(c,e,t),t},S=(d,c)=>(e,s)=>c(e,s,d);import{CancellationTokenSource as R}from"../../../../../base/common/cancellation.js";import*as A from"../../../../../base/common/errors.js";import{Emitter as _,Event as E,PauseableEmitter as x}from"../../../../../base/common/event.js";import{Lazy as F}from"../../../../../base/common/lazy.js";import{Disposable as D}from"../../../../../base/common/lifecycle.js";import{Schemas as C}from"../../../../../base/common/network.js";import"../../../../../base/common/uri.js";import{IConfigurationService as M}from"../../../../../platform/configuration/common/configuration.js";import{IInstantiationService as P}from"../../../../../platform/instantiation/common/instantiation.js";import{ILogService as N}from"../../../../../platform/log/common/log.js";import{ITelemetryService as L}from"../../../../../platform/telemetry/common/telemetry.js";import{INotebookSearchService as O}from"../../common/notebookSearch.js";import{ReplacePattern as T}from"../../../../services/search/common/replace.js";import{ISearchService as q,QueryType as H,SearchCompletionExitCode as U}from"../../../../services/search/common/search.js";import{mergeSearchResultEvents as z,SearchModelLocation as G,SEARCH_MODEL_PREFIX as j}from"./searchTreeCommon.js";import{SearchResultImpl as B}from"./searchResult.js";import"./searchViewModelWorkbenchService.js";let v=class extends D{constructor(e,s,t,a,r,u){super();this.searchService=e;this.telemetryService=s;this.configurationService=t;this.instantiationService=a;this.logService=r;this.notebookSearchService=u;this._searchResult=this.instantiationService.createInstance(B,this),this._register(this._searchResult.onChange(n=>this._onSearchResultChanged.fire(n))),this._aiTextResultProviderName=new F(async()=>this.searchService.getAIName()),this._id=j+Date.now().toString()}_searchResult;_searchQuery=null;_replaceActive=!1;_replaceString=null;_replacePattern=null;_preserveCase=!1;_startStreamDelay=Promise.resolve();_resultQueue=[];_aiResultQueue=[];_onReplaceTermChanged=this._register(new _);onReplaceTermChanged=this._onReplaceTermChanged.event;_onSearchResultChanged=this._register(new x({merge:z}));onSearchResultChanged=this._onSearchResultChanged.event;currentCancelTokenSource=null;currentAICancelTokenSource=null;searchCancelledForNewSearch=!1;aiSearchCancelledForNewSearch=!1;location=G.PANEL;_aiTextResultProviderName;_id;id(){return this._id}async getAITextResultProviderName(){const e=await this._aiTextResultProviderName.value;if(!e)throw Error("Fetching AI name when no provider present.");return e}isReplaceActive(){return this._replaceActive}set replaceActive(e){this._replaceActive=e}get replacePattern(){return this._replacePattern}get replaceString(){return this._replaceString||""}set preserveCase(e){this._preserveCase=e}get preserveCase(){return this._preserveCase}set replaceString(e){this._replaceString=e,this._searchQuery&&(this._replacePattern=new T(e,this._searchQuery.contentPattern)),this._onReplaceTermChanged.fire()}get searchResult(){return this._searchResult}async addAIResults(e){if(this.hasAIResults)throw Error("AI results already exist");if(this._searchQuery)return this.aiSearch({...this._searchQuery,contentPattern:this._searchQuery.contentPattern.pattern,type:H.aiText},e);throw Error("No search query")}aiSearch(e,s){const t=Date.now().toString(),a=new R;this.currentAICancelTokenSource=a;const r=Date.now();return this.searchService.aiTextSearch(e,a.token,async n=>{this.onSearchProgress(n,t,!1,!0),s?.(n)}).finally(()=>{a.dispose(!0)}).then(n=>(this.onSearchCompleted(n,Date.now()-r,t,!0),n),n=>{throw this.onSearchError(n,Date.now()-r,!0),n})}doSearch(e,s,t,a,r,u){const n=async h=>{s.fire(),this.onSearchProgress(h,a,!1,!1),r?.(h)},p=h=>{s.fire(),this.onSearchProgress(h,a,!0),r?.(h)},l=this.currentCancelTokenSource=new R(u),o=this.notebookSearchService.notebookSearch(e,l.token,a,n),I=this.searchService.textSearchSplitSyncAsync(t,l.token,n,o.openFilesToScan,o.allScannedFiles),i=I.syncResults.results;return i.forEach(h=>{h&&p(h)}),{asyncResults:(async()=>{const h=Date.now(),m=await I.asyncResults,g=await o.completeData,w=Date.now()-h,b={results:[...m.results,...g.results],messages:[...m.messages,...g.messages],limitHit:m.limitHit||g.limitHit,exit:m.exit,stats:m.stats};return this.logService.trace(`whole search time | ${w}ms`),b})().finally(()=>l.dispose(!0)),syncResults:i}}get hasAIResults(){return!!this.searchResult.getCachedSearchComplete(!0)||!!this.currentAICancelTokenSource&&!this.currentAICancelTokenSource.token.isCancellationRequested}get hasPlainResults(){return!!this.searchResult.getCachedSearchComplete(!1)||!!this.currentCancelTokenSource&&!this.currentCancelTokenSource.token.isCancellationRequested}search(e,s,t){this.cancelSearch(!0),this._searchQuery=e,this.searchConfig.searchOnType||this.searchResult.clear();const a=Date.now().toString();this._searchResult.query=this._searchQuery;const r=this._register(new _);this._replacePattern=new T(this.replaceString,this._searchQuery.contentPattern),this._startStreamDelay=new Promise(i=>setTimeout(i,this.searchConfig.searchOnType?150:0));const u=this.doSearch(e,r,this._searchQuery,a,s,t),n=u.asyncResults,p=u.syncResults;s&&p.forEach(i=>{i&&s(i)});const l=Date.now();let o;const I=new Promise(i=>(o=E.once(r.event)(i),o));Promise.race([n,I]).finally(()=>{o?.dispose(),this.telemetryService.publicLog("searchResultsFirstRender",{duration:Date.now()-l})});try{return{asyncResults:n.then(i=>(this.onSearchCompleted(i,Date.now()-l,a,!1),i),i=>{throw this.onSearchError(i,Date.now()-l,!1),i}),syncResults:p}}finally{this.telemetryService.publicLog("searchResultsFinished",{duration:Date.now()-l})}}onSearchCompleted(e,s,t,a){if(!this._searchQuery)throw new Error("onSearchCompleted must be called after a search is started");a?(this._searchResult.add(this._aiResultQueue,t,!0),this._aiResultQueue.length=0):(this._searchResult.add(this._resultQueue,t,!1),this._resultQueue.length=0),this.searchResult.setCachedSearchComplete(e,a);const r=Object.assign({},this._searchQuery.contentPattern);delete r.pattern;const u=e&&e.stats,n=this._searchQuery.folderQueries.every(o=>o.folder.scheme===C.file),p=this._searchQuery.folderQueries.every(o=>o.folder.scheme!==C.file),l=n?C.file:p?"other":"mixed";return this.telemetryService.publicLog("searchResultsShown",{count:this._searchResult.count(),fileCount:this._searchResult.fileCount(),options:r,duration:s,type:u&&u.type,scheme:l,searchOnTypeEnabled:this.searchConfig.searchOnType}),e}onSearchError(e,s,t){A.isCancellationError(e)&&(this.onSearchCompleted((t?this.aiSearchCancelledForNewSearch:this.searchCancelledForNewSearch)?{exit:U.NewSearchStarted,results:[],messages:[]}:void 0,s,"",t),t?this.aiSearchCancelledForNewSearch=!1:this.searchCancelledForNewSearch=!1)}onSearchProgress(e,s,t=!0,a=!1){const r=a?this._aiResultQueue:this._resultQueue;e.resource&&(r.push(e),t?r.length&&(this._searchResult.add(r,s,!1,!0),r.length=0):this._startStreamDelay.then(()=>{r.length&&(this._searchResult.add(r,s,a,!0),r.length=0)}))}get searchConfig(){return this.configurationService.getValue("search")}cancelSearch(e=!1){return this.currentCancelTokenSource?(this.searchCancelledForNewSearch=e,this.currentCancelTokenSource.cancel(),!0):!1}cancelAISearch(e=!1){return this.currentAICancelTokenSource?(this.aiSearchCancelledForNewSearch=e,this.currentAICancelTokenSource.cancel(),!0):!1}dispose(){this.cancelSearch(),this.cancelAISearch(),this.searchResult.dispose(),super.dispose()}};v=f([S(0,q),S(1,L),S(2,M),S(3,P),S(4,N),S(5,O)],v);let y=class{constructor(c){this.instantiationService=c}_searchModel=null;get searchModel(){return this._searchModel||(this._searchModel=this.instantiationService.createInstance(v)),this._searchModel}set searchModel(c){this._searchModel?.dispose(),this._searchModel=c}};y=f([S(0,P)],y);export{v as SearchModelImpl,y as SearchViewModelWorkbenchService};
