var b=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var h=(u,i,e,r)=>{for(var t=r>1?void 0:r?P(i,e):i,s=u.length-1,a;s>=0;s--)(a=u[s])&&(t=(r?a(i,e,t):a(t))||t);return r&&t&&b(i,e,t),t},n=(u,i)=>(e,r)=>i(e,r,u);import{bufferToStream as w,newWriteableBufferStream as F,VSBuffer as l}from"../../../../base/common/buffer.js";import{Disposable as O}from"../../../../base/common/lifecycle.js";import{isDefined as T}from"../../../../base/common/types.js";import{URI as g}from"../../../../base/common/uri.js";import{IEnvironmentService as B}from"../../../../platform/environment/common/environment.js";import{IFileService as E}from"../../../../platform/files/common/files.js";import{createDecorator as A}from"../../../../platform/instantiation/common/instantiation.js";import{ILogService as R}from"../../../../platform/log/common/log.js";import{IStorageService as v,StorageScope as V,StorageTarget as x}from"../../../../platform/storage/common/storage.js";import{IUriIdentityService as y}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{IWorkspaceContextService as M}from"../../../../platform/workspace/common/workspace.js";import{StoredValue as N}from"./storedValue.js";import{HydratedTestResult as W}from"./testResult.js";import"./testTypes.js";const _=128,k=16,L=1024*128,z=.2,oe=A("ITestResultStorage"),p=1;let c=class extends O{constructor(e,r,t){super();this.uriIdentityService=e;this.storageService=r;this.logService=t}stored=this._register(new N({key:"storedTestResults",scope:V.WORKSPACE,target:x.MACHINE},this.storageService));async read(){const e=await Promise.all(this.stored.get([]).map(async t=>{if(t.rev===p)try{const s=await this.readForResultId(t.id);return s?{rec:t,result:new W(this.uriIdentityService,s)}:void 0}catch(s){this.logService.warn(`Error deserializing stored test result ${t.id}`,s);return}})),r=e.filter(T);return r.length!==e.length&&this.stored.store(r.map(({rec:t})=>t)),r.map(({result:t})=>t)}getResultOutputWriter(e){const r=F();return this.storeOutputForResultId(e,r),r}async persist(e){const r=new Map(this.stored.get([]).map(({id:o,bytes:d})=>[o,d])),t=[],s=[];let a=L;for(let o=0;o<e.length&&o<_&&(a>0||t.length<k);o++){const d=e[o],f=r.get(d.id);if(f!==void 0){r.delete(d.id),t.push({id:d.id,rev:p,bytes:f}),a-=f;continue}const S=d.toJSON();if(!S)continue;const I=l.fromString(JSON.stringify(S));s.push(this.storeForResultId(d.id,S)),t.push({id:d.id,rev:p,bytes:I.byteLength}),a-=I.byteLength}for(const o of r.keys())s.push(this.deleteForResultId(o).catch(()=>{}));this.stored.store(t),await Promise.all(s)}};c=h([n(0,y),n(1,v),n(2,R)],c);class ne extends c{cache=new Map;async readForResultId(i){return Promise.resolve(this.cache.get(i))}storeForResultId(i,e){return this.cache.set(i,e),Promise.resolve()}deleteForResultId(i){return this.cache.delete(i),Promise.resolve()}readOutputForResultId(i){throw new Error("Method not implemented.")}storeOutputForResultId(i,e){throw new Error("Method not implemented.")}readOutputRangeForResultId(i,e,r){throw new Error("Method not implemented.")}}let m=class extends c{constructor(e,r,t,s,a,o){super(e,r,t);this.fileService=a;this.directory=g.joinPath(o.workspaceStorageHome,s.getWorkspace().id,"testResults")}directory;async readForResultId(e){const r=await this.fileService.readFile(this.getResultJsonPath(e));return JSON.parse(r.value.toString())}storeForResultId(e,r){return this.fileService.writeFile(this.getResultJsonPath(e),l.fromString(JSON.stringify(r)))}deleteForResultId(e){return this.fileService.del(this.getResultJsonPath(e)).catch(()=>{})}async readOutputRangeForResultId(e,r,t){try{const{value:s}=await this.fileService.readFile(this.getResultOutputPath(e),{position:r,length:t});return s}catch{return l.alloc(0)}}async readOutputForResultId(e){try{const{value:r}=await this.fileService.readFileStream(this.getResultOutputPath(e));return r}catch{return w(l.alloc(0))}}async storeOutputForResultId(e,r){await this.fileService.createFile(this.getResultOutputPath(e),r)}async persist(e){await super.persist(e),Math.random()<z&&await this.cleanupDereferenced()}async cleanupDereferenced(){const{children:e}=await this.fileService.resolve(this.directory);if(!e)return;const r=new Set(this.stored.get([]).filter(t=>t.rev===p).map(t=>t.id));await Promise.all(e.filter(t=>!r.has(t.name.replace(/\.[a-z]+$/,""))).map(t=>this.fileService.del(t.resource).catch(()=>{})))}getResultJsonPath(e){return g.joinPath(this.directory,`${e}.json`)}getResultOutputPath(e){return g.joinPath(this.directory,`${e}.output`)}};m=h([n(0,y),n(1,v),n(2,R),n(3,M),n(4,E),n(5,B)],m);export{c as BaseTestResultStorage,oe as ITestResultStorage,ne as InMemoryResultStorage,_ as RETAIN_MAX_RESULTS,m as TestResultStorage};
