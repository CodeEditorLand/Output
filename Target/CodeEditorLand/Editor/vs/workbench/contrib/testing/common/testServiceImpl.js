var H=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var w=(p,d,e,t)=>{for(var o=t>1?void 0:t?F(d,e):d,l=p.length-1,s;l>=0;l--)(s=p[l])&&(o=(t?s(d,e,o):s(o))||o);return t&&o&&H(d,e,o),o},c=(p,d)=>(e,t)=>d(e,t,p);import{groupBy as m}from"../../../../base/common/arrays.js";import{CancellationToken as h,CancellationTokenSource as C}from"../../../../base/common/cancellation.js";import{Emitter as y}from"../../../../base/common/event.js";import{Iterable as S}from"../../../../base/common/iterator.js";import{Disposable as K,toDisposable as E}from"../../../../base/common/lifecycle.js";import{observableValue as A}from"../../../../base/common/observable.js";import{isDefined as R}from"../../../../base/common/types.js";import"../../../../base/common/uri.js";import"../../../../editor/common/core/position.js";import"../../../../editor/common/languages.js";import{localize as I}from"../../../../nls.js";import{IConfigurationService as B}from"../../../../platform/configuration/common/configuration.js";import{IContextKeyService as N}from"../../../../platform/contextkey/common/contextkey.js";import{IInstantiationService as U}from"../../../../platform/instantiation/common/instantiation.js";import{INotificationService as W}from"../../../../platform/notification/common/notification.js";import{bindContextKey as P}from"../../../../platform/observable/common/platformObservableUtils.js";import{IStorageService as _,StorageScope as O,StorageTarget as V}from"../../../../platform/storage/common/storage.js";import{IUriIdentityService as z}from"../../../../platform/uriIdentity/common/uriIdentity.js";import{IWorkspaceTrustRequestService as L}from"../../../../platform/workspace/common/workspaceTrust.js";import{getTestingConfiguration as j,TestingConfigKeys as G}from"./configuration.js";import{MainThreadTestCollection as q}from"./mainThreadTestCollection.js";import{MutableObservableValue as J}from"./observableValue.js";import{StoredValue as Q}from"./storedValue.js";import{TestExclusions as X}from"./testExclusions.js";import{TestId as Y}from"./testId.js";import{TestingContextKeys as f}from"./testingContextKeys.js";import{canUseProfileWithTest as D,ITestProfileService as Z}from"./testProfileService.js";import"./testResult.js";import{ITestResultService as $}from"./testResultService.js";import"./testService.js";import{TestControllerCapability as b,TestDiffOpType as ee}from"./testTypes.js";import{IEditorService as te}from"../../../services/editor/common/editorService.js";let g=class extends K{constructor(e,t,o,l,s,i,r,a,n,u){super();this.uriIdentityService=o;this.storage=l;this.editorService=s;this.testProfiles=i;this.notificationService=r;this.configurationService=a;this.testResults=n;this.workspaceTrustRequestService=u;this.excluded=t.createInstance(X),this.isRefreshingTests=f.isRefreshingTests.bindTo(e),this.activeEditorHasTests=f.activeEditorHasTests.bindTo(e),this._register(P(f.providerCount,e,v=>this.testControllers.read(v).size));const T=(v,k)=>this._register(P(v,e,x=>S.some(this.testControllers.read(x).values(),M=>!!(M.capabilities.read(x)&k))));T(f.canRefreshTests,b.Refresh),T(f.canGoToRelatedCode,b.CodeRelatedToTest),T(f.canGoToRelatedTest,b.TestRelatedToCode),this._register(s.onDidActiveEditorChange(()=>this.updateEditorContextKeys()))}testControllers=A("testControllers",new Map);testExtHosts=new Set;cancelExtensionTestRunEmitter=new y;willProcessDiffEmitter=new y;didProcessDiffEmitter=new y;testRefreshCancellations=new Set;isRefreshingTests;activeEditorHasTests;uiRunningTests=new Map;onWillProcessDiff=this.willProcessDiffEmitter.event;onDidProcessDiff=this.didProcessDiffEmitter.event;onDidCancelTestRun=this.cancelExtensionTestRunEmitter.event;collection=new q(this.uriIdentityService,this.expandTest.bind(this));excluded;showInlineOutput=this._register(J.stored(new Q({key:"inlineTestOutputVisible",scope:O.WORKSPACE,target:V.USER},this.storage),!0));async expandTest(e,t){await this.testControllers.get().get(Y.fromString(e).controllerId)?.expandTest(e,t)}cancelTestRun(e,t){if(this.cancelExtensionTestRunEmitter.fire({runId:e,taskId:t}),e===void 0)for(const o of this.uiRunningTests.values())o.cancel();else t||this.uiRunningTests.get(e)?.cancel()}async runTests(e,t=h.None){const o=[];for(const s of e.tests){const i=o.find(a=>D(a.profile,s));if(i){i.tests.push(s);continue}const r=this.testProfiles.getDefaultProfileForTest(e.group,s);r&&o.push({profile:r,tests:[s]})}const l={targets:o.map(({profile:s,tests:i})=>({profileId:s.profileId,controllerId:i[0].controllerId,testIds:i.map(r=>r.item.extId)})),group:e.group,exclude:e.exclude?.map(s=>s.item.extId),continuous:e.continuous};if(l.targets.length===0)for(const s of m(e.tests,(i,r)=>i.controllerId===r.controllerId?0:1)){const i=this.testProfiles.getControllerProfiles(s[0].controllerId),r=s.map(a=>({profile:i.find(n=>n.group===e.group&&D(n,a)),test:a}));for(const a of m(r,(n,u)=>n.profile===u.profile?0:1)){const n=a[0].profile;n&&l.targets.push({testIds:a.map(u=>u.test.item.extId),profileId:n.profileId,controllerId:n.controllerId})}}return this.runResolvedTests(l,t)}async startContinuousRun(e,t){if(e.exclude||(e.exclude=[...this.excluded.all]),!await this.workspaceTrustRequestService.requestWorkspaceTrust({message:I("testTrust","Running tests may execute code in your workspace.")}))return;const s=m(e.targets,(i,r)=>i.controllerId.localeCompare(r.controllerId)).map(i=>this.getTestController(i[0].controllerId)?.startContinuousRun(i.map(r=>({excludeExtIds:e.exclude.filter(a=>!r.testIds.includes(a)),profileId:r.profileId,controllerId:r.controllerId,testIds:r.testIds})),t).then(r=>{const a=r.map(n=>n.error).filter(R);a.length&&this.notificationService.error(I("testError","An error occurred attempting to run tests: {0}",a.join(" ")))}));await Promise.all(s)}async runResolvedTests(e,t=h.None){e.exclude||(e.exclude=[...this.excluded.all]);const o=this.testResults.createLiveResult(e);if(!await this.workspaceTrustRequestService.requestWorkspaceTrust({message:I("testTrust","Running tests may execute code in your workspace.")}))return o.markComplete(),o;try{const s=new C(t);this.uiRunningTests.set(o.id,s);const r=m(e.targets,(a,n)=>a.controllerId.localeCompare(n.controllerId)).map(a=>this.getTestController(a[0].controllerId)?.runTests(a.map(n=>({runId:o.id,excludeExtIds:e.exclude.filter(u=>!n.testIds.includes(u)),profileId:n.profileId,controllerId:n.controllerId,testIds:n.testIds})),s.token).then(n=>{const u=n.map(T=>T.error).filter(R);u.length&&this.notificationService.error(I("testError","An error occurred attempting to run tests: {0}",u.join(" ")))}));return await this.saveAllBeforeTest(e),await Promise.all(r),o}finally{this.uiRunningTests.delete(o.id),o.markComplete()}}async provideTestFollowups(e,t){const o=await Promise.all([...this.testExtHosts].map(async s=>({ctrl:s,followups:await s.provideTestFollowups(e,t)}))),l={followups:o.flatMap(({ctrl:s,followups:i})=>i.map(r=>({message:r.title,execute:()=>s.executeTestFollowup(r.id)}))),dispose:()=>{for(const{ctrl:s,followups:i}of o)s.disposeTestFollowups(i.map(r=>r.id))}};return t.isCancellationRequested&&l.dispose(),l}publishDiff(e,t){this.willProcessDiffEmitter.fire(t),this.collection.apply(t),this.updateEditorContextKeys(),this.didProcessDiffEmitter.fire(t)}getTestController(e){return this.testControllers.get().get(e)}async syncTests(){const e=new C;try{await Promise.all([...this.testControllers.get().values()].map(t=>t.syncTests(e.token)))}finally{e.dispose(!0)}}async refreshTests(e){const t=new C;this.testRefreshCancellations.add(t),this.isRefreshingTests.set(!0);try{e?await this.getTestController(e)?.refreshTests(t.token):await Promise.all([...this.testControllers.get().values()].map(o=>o.refreshTests(t.token)))}finally{this.testRefreshCancellations.delete(t),this.isRefreshingTests.set(this.testRefreshCancellations.size>0),t.dispose(!0)}}cancelRefreshTests(){for(const e of this.testRefreshCancellations)e.cancel();this.testRefreshCancellations.clear(),this.isRefreshingTests.set(!1)}registerExtHost(e){return this.testExtHosts.add(e),E(()=>this.testExtHosts.delete(e))}async getTestsRelatedToCode(e,t,o=h.None){return(await Promise.all([...this.testExtHosts.values()].map(s=>s.getTestsRelatedToCode(e,t,o)))).flatMap(s=>s.map(i=>this.collection.getNodeById(i))).filter(R)}registerTestController(e,t){return this.testControllers.set(new Map(this.testControllers.get()).set(e,t),void 0),E(()=>{const o=[];for(const s of this.collection.rootItems)s.controllerId===e&&o.push({op:ee.Remove,itemId:s.item.extId});this.publishDiff(e,o);const l=new Map(this.testControllers.get());l.delete(e),this.testControllers.set(l,void 0)})}async getCodeRelatedToTest(e,t=h.None){return await this.testControllers.get().get(e.controllerId)?.getRelatedCode(e.item.extId,t)||[]}updateEditorContextKeys(){const e=this.editorService.activeEditor?.resource;e?this.activeEditorHasTests.set(!S.isEmpty(this.collection.getNodeByUrl(e))):this.activeEditorHasTests.set(!1)}async saveAllBeforeTest(e,t=this.configurationService,o=this.editorService){if(e.preserveFocus===!0)return;j(this.configurationService,G.SaveBeforeTest)&&await o.saveAll()}};g=w([c(0,N),c(1,U),c(2,z),c(3,_),c(4,te),c(5,Z),c(6,W),c(7,B),c(8,$),c(9,L)],g);export{g as TestService};
