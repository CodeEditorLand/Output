import{getActiveWindow as d}from"../../../base/browser/dom.js";import{Event as m}from"../../../base/common/event.js";import{MutableDisposable as v}from"../../../base/common/lifecycle.js";import{EditorOption as g}from"../../common/config/editorOptions.js";import{ViewEventHandler as B}from"../../common/viewEventHandler.js";import{GPULifecycle as f}from"./gpuDisposable.js";import{observeDevicePixelDimensions as b,quadVertices as _}from"./gpuUtils.js";import{createObjectCollectionBuffer as P}from"./objectCollectionBuffer.js";import{RectangleRendererBindingId as p,rectangleRendererWgsl as y}from"./rectangleRenderer.wgsl.js";class T extends B{constructor(e,r,i,n){super();this._context=e;this._canvas=r;this._ctx=i;this._context.addEventHandler(this),this._initWebgpu(n)}_device;_renderPassDescriptor;_renderPassColorAttachment;_bindGroup;_pipeline;_vertexBuffer;_shapeBindBuffer=this._register(new v);_scrollOffsetBindBuffer;_scrollOffsetValueBuffer;_initialized=!1;_scrollChanged=!0;_shapeCollection=this._register(P([{name:"x"},{name:"y"},{name:"width"},{name:"height"},{name:"red"},{name:"green"},{name:"blue"},{name:"alpha"}],32));async _initWebgpu(e){if(this._device=await e,this._store.isDisposed)return;const r=navigator.gpu.getPreferredCanvasFormat();this._ctx.configure({device:this._device,format:r,alphaMode:"premultiplied"}),this._renderPassColorAttachment={view:null,loadOp:"load",storeOp:"store"},this._renderPassDescriptor={label:"Monaco rectangle renderer render pass",colorAttachments:[this._renderPassColorAttachment]};let i;{let l;(t=>(t[t.FloatsPerEntry=6]="FloatsPerEntry",t[t.BytesPerEntry=24]="BytesPerEntry",t[t.Offset_CanvasWidth____=0]="Offset_CanvasWidth____",t[t.Offset_CanvasHeight___=1]="Offset_CanvasHeight___",t[t.Offset_ViewportOffsetX=2]="Offset_ViewportOffsetX",t[t.Offset_ViewportOffsetY=3]="Offset_ViewportOffsetY",t[t.Offset_ViewportWidth__=4]="Offset_ViewportWidth__",t[t.Offset_ViewportHeight_=5]="Offset_ViewportHeight_"))(l||={});const a=new Float32Array(6),h=(c=this._canvas.width,u=this._canvas.height)=>(a[0]=c,a[1]=u,a[2]=Math.ceil(this._context.configuration.options.get(g.layoutInfo).contentLeft*d().devicePixelRatio),a[3]=0,a[4]=a[0]-a[2],a[5]=a[1]-a[3],a);i=this._register(f.createBuffer(this._device,{label:"Monaco rectangle renderer uniform buffer",size:24,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST},()=>h())).object,this._register(b(this._canvas,d(),(c,u)=>{this._device.queue.writeBuffer(i,0,h(c,u))}))}const n=2;this._scrollOffsetBindBuffer=this._register(f.createBuffer(this._device,{label:"Monaco rectangle renderer scroll offset buffer",size:n*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})).object,this._scrollOffsetValueBuffer=new Float32Array(n);const s=()=>f.createBuffer(this._device,{label:"Monaco rectangle renderer shape buffer",size:this._shapeCollection.buffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});this._shapeBindBuffer.value=s(),this._register(m.runAndSubscribe(this._shapeCollection.onDidChangeBuffer,()=>{this._shapeBindBuffer.value=s(),this._pipeline&&this._updateBindGroup(this._pipeline,i)})),this._vertexBuffer=this._register(f.createBuffer(this._device,{label:"Monaco rectangle renderer vertex buffer",size:_.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST},_)).object;const o=this._device.createShaderModule({label:"Monaco rectangle renderer shader module",code:y});this._pipeline=this._device.createRenderPipeline({label:"Monaco rectangle renderer render pipeline",layout:"auto",vertex:{module:o,buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:o,targets:[{format:r,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"}}}]}}),this._updateBindGroup(this._pipeline,i),this._initialized=!0}_updateBindGroup(e,r){this._bindGroup=this._device.createBindGroup({label:"Monaco rectangle renderer bind group",layout:e.getBindGroupLayout(0),entries:[{binding:p.Shapes,resource:{buffer:this._shapeBindBuffer.value.object}},{binding:p.LayoutInfoUniform,resource:{buffer:r}},{binding:p.ScrollOffset,resource:{buffer:this._scrollOffsetBindBuffer}}]})}register(e,r,i,n,s,o,l,a){return this._shapeCollection.createEntry({x:e,y:r,width:i,height:n,red:s,green:o,blue:l,alpha:a})}onScrollChanged(e){return this._scrollChanged=!0,super.onScrollChanged(e)}_update(){const e=this._shapeCollection;if(e.dirtyTracker.isDirty&&(this._device.queue.writeBuffer(this._shapeBindBuffer.value.object,0,e.buffer,e.dirtyTracker.dataOffset,e.dirtyTracker.dirtySize*e.view.BYTES_PER_ELEMENT),e.dirtyTracker.clear()),this._scrollChanged){const r=d().devicePixelRatio;this._scrollOffsetValueBuffer[0]=this._context.viewLayout.getCurrentScrollLeft()*r,this._scrollOffsetValueBuffer[1]=this._context.viewLayout.getCurrentScrollTop()*r,this._device.queue.writeBuffer(this._scrollOffsetBindBuffer,0,this._scrollOffsetValueBuffer)}}draw(e){if(!this._initialized)return;this._update();const r=this._device.createCommandEncoder({label:"Monaco rectangle renderer command encoder"});this._renderPassColorAttachment.view=this._ctx.getCurrentTexture().createView();const i=r.beginRenderPass(this._renderPassDescriptor);i.setPipeline(this._pipeline),i.setVertexBuffer(0,this._vertexBuffer),i.setBindGroup(0,this._bindGroup),i.draw(_.length/2,this._shapeCollection.entryCount),i.end();const n=r.finish();this._device.queue.submit([n])}}export{T as RectangleRenderer};
