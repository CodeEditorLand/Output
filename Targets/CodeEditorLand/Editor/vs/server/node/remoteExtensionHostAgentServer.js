var L=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var N=(S,h,e,n)=>{for(var t=n>1?void 0:n?j(h,e):h,o=S.length-1,r;o>=0;o--)(r=S[o])&&(t=(n?r(h,e,t):r(t))||t);return n&&t&&L(h,e,t),t},k=(S,h)=>(e,n)=>h(e,n,S);import*as V from"crypto";import*as H from"fs";import"http";import*as B from"net";import{performance as q}from"perf_hooks";import*as D from"url";import{VSBuffer as b}from"../../base/common/buffer.js";import{CharCode as J}from"../../base/common/charCode.js";import{isSigPipeError as G,onUnexpectedError as z,setUnexpectedErrorHandler as K}from"../../base/common/errors.js";import{isEqualOrParent as U}from"../../base/common/extpath.js";import{Disposable as Q,DisposableStore as Z}from"../../base/common/lifecycle.js";import{connectionTokenQueryName as X,FileAccess as O,getServerRootPath as Y,Schemas as ee}from"../../base/common/network.js";import{dirname as te,join as R}from"../../base/common/path.js";import*as ne from"../../base/common/performance.js";import*as T from"../../base/common/platform.js";import{createRegExp as oe,escapeRegExpCharacters as re}from"../../base/common/strings.js";import{URI as ie}from"../../base/common/uri.js";import{generateUuid as M}from"../../base/common/uuid.js";import{getOSReleaseInfo as se}from"../../base/node/osReleaseInfo.js";import{findFreePort as ae}from"../../base/node/ports.js";import{addUNCHostToAllowlist as ce,disableUNCAccessRestrictions as de}from"../../base/node/unc.js";import{PersistentProtocol as le}from"../../base/parts/ipc/common/ipc.net.js";import{NodeSocket as A,WebSocketNodeSocket as me}from"../../base/parts/ipc/node/ipc.net.js";import{IConfigurationService as ue}from"../../platform/configuration/common/configuration.js";import{IInstantiationService as he}from"../../platform/instantiation/common/instantiation.js";import{ILogService as E}from"../../platform/log/common/log.js";import{IProductService as pe}from"../../platform/product/common/productService.js";import{ConnectionType as x}from"../../platform/remote/common/remoteAgentConnection.js";import"../../platform/remote/common/remoteAgentEnvironment.js";import{ITelemetryService as fe}from"../../platform/telemetry/common/telemetry.js";import{ExtensionHostConnection as ge}from"./extensionHostConnection.js";import{ManagementConnection as ve}from"./remoteExtensionManagement.js";import{determineServerConnectionToken as Se,requestHasValidConnectionToken as ye,ServerConnectionTokenParseError as Ce,ServerConnectionTokenType as $}from"./serverConnectionToken.js";import{IServerEnvironmentService as _e}from"./serverEnvironmentService.js";import{setupServerServices as be}from"./serverServices.js";import{CacheControl as we,serveError as w,serveFile as ke,WebClientServer as Te}from"./webClientServer.js";import{createRequire as Ee}from"node:module";const xe=Ee(import.meta.url),Pe=5*60*1e3;let P=class extends Q{constructor(e,n,t,o,r,s,c,a,u){super();this._socketServer=e;this._connectionToken=n;this._vsdaMod=t;this._environmentService=s;this._productService=c;this._logService=a;this._instantiationService=u;this._serverRootPath=Y(c,r),this._extHostConnections=Object.create(null),this._managementConnections=Object.create(null),this._allReconnectionTokens=new Set,this._webClientServer=o?this._instantiationService.createInstance(Te,this._connectionToken,r??"/",this._serverRootPath):null,this._logService.info("Extension host agent started."),this._waitThenShutdown(!0)}_extHostConnections;_managementConnections;_allReconnectionTokens;_webClientServer;_webEndpointOriginChecker=I.create(this._productService);_serverRootPath;shutdownTimer;async handleRequest(e,n){if(e.method!=="GET")return w(e,n,405,`Unsupported method ${e.method}`);if(!e.url)return w(e,n,400,"Bad request.");const t=D.parse(e.url,!0);let o=t.pathname;if(!o)return w(e,n,400,"Bad request.");if(o.startsWith(this._serverRootPath)&&o.charCodeAt(this._serverRootPath.length)===J.Slash&&(o=o.substring(this._serverRootPath.length)),o==="/version")return n.writeHead(200,{"Content-Type":"text/plain"}),void n.end(this._productService.commit||"");if(o==="/delay-shutdown")return this._delayShutdown(),n.writeHead(200),void n.end("OK");if(!ye(this._connectionToken,e,t))return w(e,n,403,"Forbidden.");if(o==="/vscode-remote-resource"){const r=t.query.path;if(typeof r!="string")return w(e,n,400,"Bad request.");let s;try{s=ie.from({scheme:ee.file,path:r}).fsPath}catch{return w(e,n,400,"Bad request.")}const c=Object.create(null);this._environmentService.isBuilt&&(U(s,this._environmentService.builtinExtensionsPath,!T.isLinux)||U(s,this._environmentService.extensionsPath,!T.isLinux))&&(c["Cache-Control"]="public, max-age=31536000"),c.Vary="Origin";const a=e.headers.origin;return a&&this._webEndpointOriginChecker.matches(a)&&(c["Access-Control-Allow-Origin"]=a),ke(s,we.ETAG,this._logService,e,n,c)}if(this._webClientServer){this._webClientServer.handle(e,n,t);return}return n.writeHead(404,{"Content-Type":"text/plain"}),void n.end("Not found")}handleUpgrade(e,n){let t=M(),o=!1,r=!1;if(e.url){const m=D.parse(e.url,!0).query;typeof m.reconnectionToken=="string"&&(t=m.reconnectionToken),m.reconnection==="true"&&(o=!0),m.skipWebSocketFrames==="true"&&(r=!0)}if(e.headers.upgrade===void 0||e.headers.upgrade.toLowerCase()!=="websocket"){n.end("HTTP/1.1 400 Bad Request");return}const s=e.headers["sec-websocket-key"],c=V.createHash("sha1");c.update(s+"258EAFA5-E914-47DA-95CA-C5AB0DC85B11");const u=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${c.digest("base64")}`];let l=!1;if(!r&&!this._environmentService.args["disable-websocket-compression"]&&e.headers["sec-websocket-extensions"]){const m=Array.isArray(e.headers["sec-websocket-extensions"])?e.headers["sec-websocket-extensions"]:[e.headers["sec-websocket-extensions"]];for(const f of m)if(!/\b((server_max_window_bits)|(server_no_context_takeover)|(client_no_context_takeover))\b/.test(f)){if(/\b(permessage-deflate)\b/.test(f)){l=!0,u.push("Sec-WebSocket-Extensions: permessage-deflate");break}if(/\b(x-webkit-deflate-frame)\b/.test(f)){l=!0,u.push("Sec-WebSocket-Extensions: x-webkit-deflate-frame");break}}}n.write(u.join(`\r
`)+`\r
\r
`),n.setTimeout(0),n.setNoDelay(!0),r?this._handleWebSocketConnection(new A(n,`server-connection-${t}`),o,t):this._handleWebSocketConnection(new me(new A(n,`server-connection-${t}`),l,null,!0),o,t)}handleServerError(e){this._logService.error("Error occurred in server"),this._logService.error(e)}_getRemoteAddress(e){let n;return e instanceof A?n=e.socket:n=e.socket.socket,n.remoteAddress||"<unknown>"}async _rejectWebSocketConnection(e,n,t){const o=n.getSocket();this._logService.error(`${e} ${t}.`);const r={type:"error",reason:t};n.sendControl(b.fromString(JSON.stringify(r))),n.dispose(),await o.drain(),o.dispose()}_handleWebSocketConnection(e,n,t){const o=this._getRemoteAddress(e),r=`[${o}][${t.substr(0,8)}]`,s=new le({socket:e}),c=this._vsdaMod?new this._vsdaMod.validator:null,a=this._vsdaMod?new this._vsdaMod.signer:null;let u;(i=>(i[i.WaitingForAuth=0]="WaitingForAuth",i[i.WaitingForConnectionType=1]="WaitingForConnectionType",i[i.Done=2]="Done",i[i.Error=3]="Error"))(u||={});let l=0;const m=_=>{l=3,f.dispose(),this._rejectWebSocketConnection(r,s,_)},f=s.onControlMessage(_=>{if(l===0){let p;try{p=JSON.parse(_.toString())}catch{return m("Malformed first message")}if(p.type!=="auth")return m("Invalid first message");if(this._connectionToken.type===$.Mandatory&&!this._connectionToken.validate(p.auth))return m("Unauthorized client refused: auth mismatch");let y=M();if(a)try{y=a.sign(p.data)}catch{}let v=M();if(c)try{v=c.createNewMessage(v)}catch{}const i={type:"sign",data:v,signedData:y};s.sendControl(b.fromString(JSON.stringify(i))),l=1}else if(l===1){let p;try{p=JSON.parse(_.toString())}catch{return m("Malformed second message")}if(p.type!=="connectionType")return m("Invalid second message");if(typeof p.signedData!="string")return m("Invalid second message field type");const y=p.commit,v=this._productService.commit;if(y&&v&&y!==v)return m("Client refused: version mismatch");let i=!1;if(!c)i=!0;else if(this._connectionToken.validate(p.signedData))i=!0;else try{i=c.validate(p.signedData)==="ok"}catch{}if(!i){if(this._environmentService.isBuilt)return m("Unauthorized client refused");this._logService.error(`${r} Unauthorized client handshake failed but we proceed because of dev mode.`)}for(const d in this._managementConnections)this._managementConnections[d].shortenReconnectionGraceTimeIfNecessary();for(const d in this._extHostConnections)this._extHostConnections[d].shortenReconnectionGraceTimeIfNecessary();l=2,f.dispose(),this._handleConnectionType(o,r,s,e,n,t,p)}})}async _handleConnectionType(e,n,t,o,r,s,c){const a=c.desiredConnectionType===x.Management?`${n}[ManagementConnection]`:c.desiredConnectionType===x.ExtensionHost?`${n}[ExtensionHostConnection]`:n;if(c.desiredConnectionType===x.Management)if(r){if(!this._managementConnections[s])return this._allReconnectionTokens.has(s)?this._rejectWebSocketConnection(a,t,"Unknown reconnection token (seen before)"):this._rejectWebSocketConnection(a,t,"Unknown reconnection token (never seen)");t.sendControl(b.fromString(JSON.stringify({type:"ok"})));const u=t.readEntireBuffer();t.dispose(),this._managementConnections[s].acceptReconnection(e,o,u)}else{if(this._managementConnections[s])return this._rejectWebSocketConnection(a,t,"Duplicate reconnection token");t.sendControl(b.fromString(JSON.stringify({type:"ok"})));const u=new ve(this._logService,s,e,t);this._socketServer.acceptConnection(u.protocol,u.onClose),this._managementConnections[s]=u,this._allReconnectionTokens.add(s),u.onClose(()=>{delete this._managementConnections[s]})}else if(c.desiredConnectionType===x.ExtensionHost){const u=c.args||{language:"en"},l=await this._updateWithFreeDebugPort(u);if(l.port&&this._logService.trace(`${a} - startParams debug port ${l.port}`),this._logService.trace(`${a} - startParams language: ${l.language}`),this._logService.trace(`${a} - startParams env: ${JSON.stringify(l.env)}`),r){if(!this._extHostConnections[s])return this._allReconnectionTokens.has(s)?this._rejectWebSocketConnection(a,t,"Unknown reconnection token (seen before)"):this._rejectWebSocketConnection(a,t,"Unknown reconnection token (never seen)");t.sendPause(),t.sendControl(b.fromString(JSON.stringify(l.port?{debugPort:l.port}:{})));const m=t.readEntireBuffer();t.dispose(),this._extHostConnections[s].acceptReconnection(e,o,m)}else{if(this._extHostConnections[s])return this._rejectWebSocketConnection(a,t,"Duplicate reconnection token");t.sendPause(),t.sendControl(b.fromString(JSON.stringify(l.port?{debugPort:l.port}:{})));const m=t.readEntireBuffer();t.dispose();const f=this._instantiationService.createInstance(ge,s,e,o,m);this._extHostConnections[s]=f,this._allReconnectionTokens.add(s),f.onClose(()=>{f.dispose(),delete this._extHostConnections[s],this._onDidCloseExtHostConnection()}),f.start(l)}}else if(c.desiredConnectionType===x.Tunnel){const u=c.args;this._createTunnel(t,u)}else return this._rejectWebSocketConnection(a,t,"Unknown initial data received")}async _createTunnel(e,n){const t=e.getSocket().socket,o=e.readEntireBuffer();e.dispose(),t.pause();const r=await this._connectTunnelSocket(n.host,n.port);o.byteLength>0&&r.write(o.buffer),r.on("end",()=>t.end()),r.on("close",()=>t.end()),r.on("error",()=>t.destroy()),t.on("end",()=>r.end()),t.on("close",()=>r.end()),t.on("error",()=>r.destroy()),r.pipe(t),t.pipe(r)}_connectTunnelSocket(e,n){return new Promise((t,o)=>{const r=B.createConnection({host:e,port:n,autoSelectFamily:!0},()=>{r.removeListener("error",o),r.pause(),t(r)});r.once("error",o)})}_updateWithFreeDebugPort(e){return typeof e.port=="number"?ae(e.port,10,5e3).then(n=>(e.port=n,e)):(e.debugId=void 0,e.port=void 0,e.break=void 0,Promise.resolve(e))}async _onDidCloseExtHostConnection(){if(!this._environmentService.args["enable-remote-auto-shutdown"])return;this._cancelShutdown(),!!Object.keys(this._extHostConnections).length||(this._logService.info("Last EH closed, waiting before shutting down"),this._waitThenShutdown())}_waitThenShutdown(e=!1){this._environmentService.args["enable-remote-auto-shutdown"]&&(this._environmentService.args["remote-auto-shutdown-without-delay"]&&!e?this._shutdown():this.shutdownTimer=setTimeout(()=>{this.shutdownTimer=void 0,this._shutdown()},Pe))}_shutdown(){if(!!Object.keys(this._extHostConnections).length){this._logService.info("New EH opened, aborting shutdown");return}else this._logService.info("Last EH closed, shutting down"),this.dispose(),process.exit(0)}_delayShutdown(){this.shutdownTimer&&(this._logService.info("Got delay-shutdown request while in shutdown timeout, delaying"),this._cancelShutdown(),this._waitThenShutdown())}_cancelShutdown(){this.shutdownTimer&&(this._logService.info("Cancelling previous shutdown timeout"),clearTimeout(this.shutdownTimer),this.shutdownTimer=void 0)}};P=N([k(5,_e),k(6,pe),k(7,E),k(8,he)],P);async function vt(S,h,e){const n=await Se(h);n instanceof Ce&&process.exit(1);function t(i){K(d=>{G(d)&&d.stack&&/unexpectedErrorHandler/.test(d.stack)||i(d)})}const o=[];t(i=>{o.push(i)});let r=!1;process.on("SIGPIPE",()=>{r||(r=!0,z(new Error("Unexpected SIGPIPE")))});const s=new Z,{socketServer:c,instantiationService:a}=await be(n,h,e,s);a.invokeFunction(i=>{const d=i.get(E);o.forEach(g=>d.error(g)),o.length=0,t(g=>d.error(g))}),a.invokeFunction(i=>{const d=i.get(ue);T.isWindows&&(d.getValue("security.restrictUNCAccess")===!1?de():ce(d.getValue("security.allowedUNCHosts")))}),a.invokeFunction(i=>{const d=i.get(E);if(T.isWindows&&process.env.HOMEDRIVE&&process.env.HOMEPATH){const g=R(process.env.HOMEDRIVE,"node_modules"),C=te(R(process.env.HOMEDRIVE,process.env.HOMEPATH)),W=R(C,"node_modules");if(H.existsSync(g)||H.existsSync(W)){const F=`

*
* !!!! Server terminated due to presence of CVE-2020-1416 !!!!
*
* Please remove the following directories and re-try
* ${g}
* ${W}
*
* For more information on the vulnerability https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1416
*

`;d.warn(F),process.exit(0)}}});const u=a.invokeFunction(i=>{const d=i.get(E);if(H.existsSync(R(O.asFileUri("").fsPath,"../node_modules/vsda")))try{return xe("vsda")}catch(C){d.error(C)}return null});let l=h["server-base-path"];l&&!l.startsWith("/")&&(l=`/${l}`);const m=H.existsSync(O.asFileUri("vs/code/browser/workbench/workbench.html").fsPath);if(m&&S&&typeof S!="string"){const i=n.type!==$.None?`?${X}=${n.value}`:""}const f=a.createInstance(P,c,n,u,m,l);ne.mark("code/server/ready");const _=q.now(),p=global.vscodeServerStartTime,y=global.vscodeServerListenTime,v=global.vscodeServerCodeLoadedTime;if(a.invokeFunction(async i=>{const d=i.get(fe);if(d.publicLog2("serverStart",{startTime:p,startedTime:y,codeLoadedTime:v,readyTime:_}),T.isLinux){const g=i.get(E),C=await se(g.error.bind(g));C&&d.publicLog2("serverPlatformInfo",{platformId:C.id,platformVersionId:C.version_id,platformIdLike:C.id_like})}}),h["print-startup-performance"]){let i="";i+=`Start-up time: ${y-p}
`,i+=`Code loading time: ${v-p}
`,i+=`Initialized time: ${_-p}
`,i+=`
`}return f}class I{constructor(h){this._originRegExp=h}static create(h){const e=h.webEndpointUrlTemplate,n=h.commit,t=h.quality;if(!e||!n||!t)return new I(null);const o=M(),s=new URL(e.replace("{{uuid}}",o).replace("{{commit}}",n).replace("{{quality}}",t)).origin,c=re(s).replace(o,"[a-zA-Z0-9\\-]+");try{const a=oe(`^${c}$`,!0,{matchCase:!1});return new I(a)}catch{return new I(null)}}matches(h){return this._originRegExp?this._originRegExp.test(h):!1}}export{vt as createServer};
