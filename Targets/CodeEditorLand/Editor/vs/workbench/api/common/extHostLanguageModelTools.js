import{raceCancellation as l}from"../../../base/common/async.js";import{CancellationToken as c}from"../../../base/common/cancellation.js";import{CancellationError as g}from"../../../base/common/errors.js";import{toDisposable as u}from"../../../base/common/lifecycle.js";import{revive as T}from"../../../base/common/marshalling.js";import{generateUuid as d}from"../../../base/common/uuid.js";import"../../../platform/extensions/common/extensions.js";import"../../contrib/chat/common/languageModelToolsService.js";import{MainContext as p}from"./extHost.protocol.js";import*as i from"./extHostTypeConverters.js";class F{_registeredTools=new Map;_proxy;_tokenCountFuncs=new Map;_allTools=new Map;constructor(o){this._proxy=o.getProxy(p.MainThreadLanguageModelTools),this._proxy.$getTools().then(e=>{for(const n of e)this._allTools.set(n.id,T(n))})}async $countTokensForInvocation(o,e,n){const s=this._tokenCountFuncs.get(o);if(!s)throw new Error(`Tool invocation call ${o} not found`);return await s(e,n)}async invokeTool(o,e,n){if(!e.requestedContentTypes?.length)throw new Error("LanguageModelToolInvocationOptions.requestedContentTypes is required to be set");const s=d();e.tokenOptions&&this._tokenCountFuncs.set(s,e.tokenOptions.countTokens);try{return await this._proxy.$invokeTool({toolId:o,callId:s,parameters:e.parameters,tokenBudget:e.tokenOptions?.tokenBudget,context:e.toolInvocationToken,requestedContentTypes:e.requestedContentTypes},n)}finally{this._tokenCountFuncs.delete(s)}}$onDidChangeTools(o){this._allTools.clear();for(const e of o)this._allTools.set(e.id,e)}get tools(){return Array.from(this._allTools.values()).map(o=>i.LanguageModelToolDescription.to(o))}async $invokeTool(o,e){const n=this._registeredTools.get(o.toolId);if(!n)throw new Error(`Unknown tool ${o.toolId}`);const s={parameters:o.parameters,toolInvocationToken:o.context,requestedContentTypes:o.requestedContentTypes};o.tokenBudget!==void 0&&(s.tokenOptions={tokenBudget:o.tokenBudget,countTokens:this._tokenCountFuncs.get(o.callId)||((t,a=c.None)=>this._proxy.$countTokensForInvocation(o.callId,t,a))});const r=await l(Promise.resolve(n.tool.invoke(s,e)),e);if(!r)throw new g;for(const t of Object.keys(r)){if(r[t]instanceof Promise)throw new Error(`Tool result for '${t}' cannot be a Promise`);if(!s.requestedContentTypes.includes(t)&&t!=="toString")throw new Error(`Tool result for '${t}' was not requested from ${o.toolId}.`)}return r}async $prepareToolInvocation(o,e,n,s){const r=this._registeredTools.get(o);if(!r)throw new Error(`Unknown tool ${o}`);if(!r.tool.prepareToolInvocation)return;const t=await r.tool.prepareToolInvocation({participantName:e,parameters:n},s);if(t)return{confirmationMessages:t.confirmationMessages?{title:t.confirmationMessages.title,message:typeof t.confirmationMessages.message=="string"?t.confirmationMessages.message:i.MarkdownString.from(t.confirmationMessages.message)}:void 0,invocationMessage:t.invocationMessage}}registerTool(o,e,n){return this._registeredTools.set(e,{extension:o,tool:n}),this._proxy.$registerTool(e),u(()=>{this._registeredTools.delete(e),this._proxy.$unregisterTool(e)})}}export{F as ExtHostLanguageModelTools};
